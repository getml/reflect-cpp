{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome","text":"<p>\ud83d\udcbb Source Code: https://github.com/getml/reflect-cpp</p> <p>reflect-cpp is a C++-20 library for fast serialization, deserialization and validation using reflection, similar to pydantic in Python, serde in Rust, encoding in Go or aeson in Haskell.</p> <p>reflect-cpp fills an important gap in C++ development. It minimizes boilerplate code and enhances code safety for seamless and efficient data exchange across system components.</p> Design principles for reflect-cpp include: <ul> <li>Close integration with containers from the C++ standard library</li> <li>Close adherence to C++ idioms</li> <li>Out-of-the-box support for JSON</li> <li>Simple installation</li> <li>Simple extendability to other serialization formats</li> <li>Simple extendability to custom classes</li> <li>Being one of the fastest serialization libraries in existence, as demonstrated by our benchmarks</li> </ul>"},{"location":"#reflect-cpp","title":"reflect-cpp","text":""},{"location":"#why-do-we-need-this","title":"Why do we need this?","text":"<p>Suppose your C++ program has complex data structures it needs to save and load. Or maybe it needs to interact with some kind of external API. If you do this the traditional way, you will have a lot of boilerplate code. This is annoying and error-prone.</p> <p>Example</p> <p>If you are new to reflect-cpp, please refer to our GitHub repository for the latest list of supported serialization formats. You will also find a simple and more comprehensive code example.</p> <p>reflect-cpp is not just a reflection library, it is for serialization, deserialization and validation through reflection.</p> <p>That means that you can encode your requirements about the input data in the type system and have them validated upfront. This is why the library also includes algebraic data types like tagged unions and numerous validation routines. Having your requirements encoded in the type system is the most reliable way of ensuring they are met. If your requirements are not met, the user of your software gets a very clear error message. Encoding your requirements in the type system also makes it a lot easier for anyone reading your code.</p> <p>This increases user experience and developer experience, it makes your code safer (fewer bugs) and more secure (less prone to malicious attacks).</p> <p>For a more in-depth theoretical discussions of these topics, the following books are warmly recommended:</p> <ul> <li>Category Theory for Programmers by Bartosz Milewski on GitHub</li> <li>Domain Modeling Made Functional by Scott Wlaschin</li> </ul>"},{"location":"#the-team-behind-reflect-cpp","title":"The team behind reflect-cpp","text":"<p>reflect-cpp has been developed by getML (Code17 GmbH), a company specializing in software engineering and machine learning for enterprise applications. reflect-cpp is currently maintained by Patrick Urbanke and Manuel Bellersen, with major contributions coming from the community.</p>"},{"location":"#related-projects","title":"Related projects","text":"<p>reflect-cpp was originally developed for getml-community, the fastest open-source tool for feature engineering on relational data and time series. If you are interested in Data Science and/or Machine Learning, please check it out.</p>"},{"location":"#professional-c-support","title":"Professional C++ support","text":"<p>For comprehensive C++ support beyond the scope of GitHub discussions, we\u2019re here to help! Reach out at support@getml.com to discuss any technical challenges or project requirements. We\u2019re excited to support your work as independent software consultants.</p>"},{"location":"#license","title":"License","text":"<p>reflect-cpp is released under the MIT License.</p>"},{"location":"as/","title":"<code>rfl::as</code>","text":"<p><code>rfl::as</code> allows you to cast structs as other structs. This is useful if the fields in <code>B</code> are a subset of the fields in <code>A</code> or we need the fields in <code>A</code> and <code>B</code> to produce <code>C</code>.</p> <p>This only works for the <code>rfl::Field</code>-syntax.</p> <p>For example:</p> <pre><code>struct A {\n    std::string f1;\n    std::string f2;\n};\n\nstruct B {\n    std::string f3;\n    std::string f4;\n};\n\nstruct C {\n    std::string f1;\n    std::string f2;\n    std::string f4;\n};\n\nconst auto a = A{.f1 = \"Hello\", .f2 = \"World\"};\n\nconst auto b = B{.f3 = \"Hello\", .f4 = \"World\"};\n\n// Creates c by retrieving f1 and f2 from a and f4 from b. \n// Ignores f3.\nconst auto c = rfl::as&lt;C&gt;(a, b);\n</code></pre> <p>In this case, <code>f1</code>, <code>f2</code> and <code>f4</code> are now copied into the newly created <code>c</code> of type <code>C</code>.</p> <p>Much like <code>rfl::replace</code>, <code>rfl::as</code> supports move semantics:</p> <pre><code>auto a = A{.f1 = \"Hello\", .f2 = \"World\"};\n\nauto b = B{.f3 = \"Hello\", .f4 = \"World\"};\n\nconst auto c = rfl::as&lt;C&gt;(std::move(a), std::move(b));\n</code></pre> <p>In this case, <code>f1</code>, <code>f2</code> and <code>f4</code> are now moved into the newly created <code>c</code> of type <code>C</code>. This is a zero-copy operation. <code>f3</code> is discarded.</p> <p><code>rfl::as</code> also supports <code>rfl::Flatten</code>. For instance:</p> <pre><code>struct A {\n    std::string f1;\n    std::string f2;\n};\n\nstruct B {\n    std::string f3;\n    std::string f4;\n};\n\nstruct C {\n    rfl::Flatten&lt;A&gt; a;\n    rfl::Flatten&lt;B&gt; b;\n    int f5;\n};\n\nconst auto a = A{.f1 = \"Hello\", .f2 = \"World\"};\n\nconst auto b = B{.f3 = \"Hello\", .f4 = \"World\"};\n\nconst auto c =\n    rfl::as&lt;C&gt;(a, b, rfl::make_field&lt;\"f5\"&gt;(5));\n</code></pre> <p>In this particular instance, <code>rfl::as&lt;C&gt;(...)</code> is basically equivalent to this:</p> <pre><code>const auto c = C{.a = a, .b = b, .f5 = rfl::make_field&lt;\"f5\"&gt;(5)};\n</code></pre>"},{"location":"backwards_compatability/","title":"Maintaining backwards compatability","text":"<p>If you change your structs, you probably want to be able to interact with data generated by previous versions of your structs. This section explains how you can do that.</p> <p>For the purpose of this section, any field of type <code>std::optional</code>, <code>std::shared_ptr</code> or <code>std::unique_ptr</code> is an optional field. Any other fields are required.</p> <p>Please refer to the section on optional fields for details.</p>"},{"location":"backwards_compatability/#rules","title":"Rules","text":"<p>The following rules apply:</p> <ul> <li>You can add optional fields.</li> <li>You can remove any optional or required fields, if they are no longer needed.</li> <li>You can change the field names of any optional fields.</li> <li>You can change the order of any existing fields.</li> <li>You can not add any required fields.</li> <li>You can not change the field names of any required fields.</li> </ul>"},{"location":"backwards_compatability/#api-versioning","title":"API versioning","text":"<p>If you find it difficult to follow the rules as stated above or you cannot guarantee that you will always be able to follow them in the future, you might want to use API versioning.</p> <p>You can either use <code>rfl::TaggedUnion</code> or externally tagged variants:</p> <pre><code>struct API_v_1_0 {\n  using Tag = rfl::Literal&lt;\"v1.0\"&gt;;\n  ...\n};\n\nstruct API_v_1_1 {\n  using Tag = rfl::Literal&lt;\"v1.1\"&gt;;\n  ...\n};\n\n...\n\nusing APIs = rfl::TaggedUnion&lt;\"version\", API_v_1_0, API_v_1_1, ...&gt;;\n</code></pre> <pre><code>struct API_v_1_0 {\n  ...\n};\n\nstruct API_v_1_1 {\n  ...\n};\n\n...\n\nusing APIs = rfl::Variant&lt;rfl::Field&lt;\"v1.0\", API_v_1_0&gt;, rfl::Field&lt;\"v1.1\", API_v_1_1&gt;, ...&gt;;\n</code></pre>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>reflect-cpp conducts continuuous benchmarking across different operating systems, compilers and architectures and publishes the results on its Actions tab. Refer to the benchmarks folder for details.</p> <p>The benchmarks show that reflect-cpp is not only very convenient, but also one the fastest JSON libraries for C++. It is faster than RapidJSON and about 10 times faster than nlohmann/json. It can be even faster than that,  if you choose to use a different format supported by reflect-cpp, such as msgpack.</p>"},{"location":"bytestring/","title":"<code>rfl::Bytestring</code>","text":"<p><code>rfl::Bytestring</code> is a simple alias:</p> <pre><code>namespace rfl {\n\nusing Bytestring = std::vector&lt;std::byte&gt;;\n\n}\n</code></pre> <p>Bytestrings are supported by binary formats such as BSON, CBOR, flexbuffers and msgpack.  Textual formats do not support them.</p>"},{"location":"c_arrays_and_inheritance/","title":"C Arrays and inheritance","text":"<p>reflect-cpp supports fixed-size C arrays and some forms of inheritance, but only as an opt-in.</p> <p>We have made this design decision, because checking for C arrays and inheritance  requires a disproportionate amount of compile time and we believe it is more important to reduce compile time than to support things out-of-the-box that most people won't need anyway. Since there are good alternatives for  both of these problems, it is recommended to avoid using C arrays or  inheritance altogether.</p> <p>Note that C arrays are not the same thing as <code>std::array</code>. <code>std::array</code> is always supported and is the recommended alternative.</p> <p>If you want support for these, you will have to pass the flag <code>-D REFLECT_CPP_C_ARRAYS_OR_INHERITANCE</code> during compilation.</p>"},{"location":"c_arrays_and_inheritance/#c-arrays","title":"C arrays","text":"<p>Suppose you have a struct like this:</p> <pre><code>struct Person{\n    std::string first_name;  \n    std::string last_name; \n    int[5] post_code;\n};\n</code></pre> <p>In this example, <code>post_code</code> is a C array. The best way to handle this is to simply replace the C array with <code>std::array</code>, like this:</p> <pre><code>struct Person{\n    std::string first_name;  \n    std::string last_name; \n    std::array&lt;int, 5&gt; post_code;\n};\n</code></pre> <p>However, in some cases, using C arrays is unavoidable. For instance <code>bson_oid_t</code> contains a C array under-the-hood, so if you want to parse a <code>bson_oid_t</code> you will have no choice but to pass the flag mentioned above.</p>"},{"location":"c_arrays_and_inheritance/#inheritance","title":"Inheritance","text":"<p>reflect-cpp supports some form of inheritance. Because we use structured bindings to retrieve the fields of a struct, there are limitations on what we can do when it comes to inheritance:</p> <p>Every non-static data member of E must be a direct member of E or the same base class of E.  (https://en.cppreference.com/w/cpp/language/structured_binding)</p> <p>In other words, all of the fields must be inside the same struct.</p> <p>So, this is fine:</p> <pre><code>struct Base {\n int x;\n};\n\nstruct Derived : Base {};\n</code></pre> <p>This is fine as well:</p> <pre><code>struct Base {};\nstruct Derived : Base {\n  int x;\n};\n</code></pre> <p>But this is not fine, because the fields are spread out over more than one struct:</p> <pre><code>struct Base {\n   int x;\n};\n\nstruct Derived : Base {\n  int y;\n};\n</code></pre> <p>The recommended alternative is to simply use <code>rfl::Flatten</code>, which has no such limitation:</p> <pre><code>struct Base {\n   int x;\n};\n\nstruct Derived {\n  rfl::Flatten&lt;Base&gt; base; \n  int y;\n};\n</code></pre> <p>Please refer to the section on <code>rfl::Flatten</code> in this documentation for more information.</p> <p>If for any reason you want to use inheritance patterns like the ones described above, you will make have to make sure that all of the fields are inside the same struct and also you will also have to pass the  compile time flag mentioned above.</p>"},{"location":"composing_validators/","title":"Composing validators","text":"<p>Sometimes the conditions you want to impose are more complex than a simple minimum or a simple regex pattern. That is why reflect-cpp allows you to compose them using the operators <code>rfl::AnyOf</code>, <code>rfl::AllOf</code> and <code>rfl::OneOf</code>.</p> <ul> <li><code>rfl::AnyOf</code> requires that at least one of the conditions contained therein be true. It thus works like an OR operator.</li> <li><code>rfl::AllOf</code> requires that all of the conditions contained therein be true. It thus works like an AND operator.</li> <li><code>rfl::OneOf</code> requires that exactly one of the conditions contained therein be true. It thus works like a XOR operator.</li> </ul> <p>For instance, if you want to ensure that a person's age is a reasonable number, you can impose two conditions as follows:</p> <pre><code>using Age = rfl::Validator&lt;int,\n                           rfl::AllOf&lt;rfl::Minimum&lt;0&gt;, rfl::Maximum&lt;130&gt;&gt;&gt;;\n\nstruct Person {\n  rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n  rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n  Age age;\n};\n</code></pre> <p>However, if you pass more than one constraint to <code>rfl::Validator</code>, they will be automatically connected using <code>rfl::AllOf</code>, so you might as well write:</p> <pre><code>using Age = rfl::Validator&lt;int, rfl::Minimum&lt;0&gt;, rfl::Maximum&lt;130&gt;&gt;;\n\n...\n</code></pre> <p>You can also nest composed validators. For instance, in this case the age must either be 0-10 or 40-130.</p> <pre><code>using Age = rfl::Validator&lt;\n    int,\n    rfl::AnyOf&lt;rfl::AllOf&lt;rfl::Minimum&lt;0&gt;, rfl::Maximum&lt;10&gt;&gt;,\n               rfl::AllOf&lt;rfl::Minimum&lt;40&gt;, rfl::Maximum&lt;130&gt;&gt;&gt;&gt;;\n</code></pre> <p>You can also compose regex patterns:</p> <pre><code>using TableOrColumnName = rfl::Validator&lt;\n    std::string,\n    rfl::AnyOf&lt;rfl::PatternValidator&lt;R\"(^[A-Z]+(?:_[A-Z]+)*$)\", \"TableName\"&gt;,\n               rfl::PatternValidator&lt;R\"(^[a-z]+(?:_[a-z]+)*$)\", \"ColumnName\"&gt;&gt;&gt;;\n</code></pre>"},{"location":"contributing/","title":"How to contribute","text":""},{"location":"contributing/#setup","title":"Setup","text":"<p>Make sure includes are relative.</p> <p>We need internal includes to be relative and not depend on any externally set include directory.</p> <p>That is, for example, if you are within any file in <code>rfl/internal</code>, prefer <pre><code>#include \"to_ptr_named_tuple.hpp\"\n</code></pre> over <pre><code>#include \"rfl/internal/to_ptr_named_tuple.hpp\"\n</code></pre> For further details and reasoning, please refer to #30.</p>"},{"location":"contributing/#compiling-and-running-the-tests","title":"Compiling and running the tests","text":"<p>reflect-cpp uses vcpkg for dependency management, including gtest, which is required for the tests.</p> <pre><code># bootstrap vcpkg if you haven't done so already \ngit submodule update --init\n./vcpkg/bootstrap-vcpkg.sh # Linux, macOS\n./vcpkg/bootstrap-vcpkg.bat # Windows\n# You may be prompted to install additional dependencies.\n</code></pre>"},{"location":"contributing/#json-only","title":"JSON only","text":"<p>To compile the tests, do the following:</p> <pre><code>cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DREFLECTCPP_BUILD_TESTS=ON\ncmake --build build -j 4 # gcc, clang\ncmake --build build --config Release -j 4 # MSVC\n</code></pre> <p>To run the tests, do the following:</p> <pre><code>./build/tests/json/reflect-cpp-json-tests\n</code></pre>"},{"location":"contributing/#all-serialization-formats","title":"All serialization formats","text":"<p>To compile the tests with serialization formats other than JSON, do the following:</p> <pre><code>cmake -S . -B build -DREFLECTCPP_BUILD_TESTS=ON -DREFLECTCPP_BSON=ON -DREFLECTCPP_CBOR=ON -DREFLECTCPP_FLEXBUFFERS=ON -DREFLECTCPP_MSGPACK=ON -DREFLECTCPP_XML=ON -DREFLECTCPP_TOML=ON -DREFLECTCPP_UBJSON=ON -DREFLECTCPP_YAML=ON -DCMAKE_BUILD_TYPE=Release\ncmake --build build -j 4 # gcc, clang\ncmake --build build --config Release -j 4 # MSVC\n</code></pre> <p>To run the tests, do the following:</p> <pre><code>./build/tests/bson/reflect-cpp-bson-tests\n./build/tests/cbor/reflect-cpp-cbor-tests\n./build/tests/flexbuffers/reflect-cpp-flexbuffers-tests\n./build/tests/msgpack/reflect-cpp-msgpack-tests\n./build/tests/json/reflect-cpp-json-tests\n./build/tests/toml/reflect-cpp-toml-tests\n./build/tests/ubjson/reflect-cpp-ubjson-tests\n./build/tests/xml/reflect-cpp-xml-tests\n./build/tests/yaml/reflect-cpp-yaml-tests\n</code></pre>"},{"location":"custom_parser/","title":"Custom parsers","text":""},{"location":"custom_parser/#rflreflector","title":"<code>rfl::Reflector</code>","text":"<p>If you absolutely do not want to (or are unable to) make any changes to your original classes whatsoever, you can create a Reflector template specialization for your type:</p> <pre><code>namespace rfl {\ntemplate &lt;&gt;\nstruct Reflector&lt;Person&gt; {\n  struct ReflType {\n    std::string first_name;\n    std::string last_name;\n  };\n\n  static Person to(const ReflType&amp; v) noexcept {\n    return {v.first_name, v.last_name};\n  }\n\n  static ReflType from(const Person&amp; v) {\n    return {v.first_name, v.last_name};\n  }\n};\n}\n</code></pre> <p>One way to help make sure that your <code>ReflType</code> is kept up to date with your original class is to use the <code>rfl::num_fields&lt;T&gt;</code> utility to implement a compile- time assertion to verify that they have the same number of fields. The <code>rfl::num_fields&lt;T&gt;</code> utility can be used even in cases where the original class is too complex for <code>reflect-cpp</code>'s default reflection logic or <code>rfl::to_view()</code> to be able to handle.</p> <pre><code>namespace rfl {\ntemplate &lt;&gt;\nstruct Reflector&lt;Person&gt; {\n  struct ReflType {\n    std::string first_name;\n    std::string last_name;\n  };\n  static_assert(rfl::num_fields&lt;ReflType&gt; == rfl::num_fields&lt;Person&gt;,\n    \"ReflType and actual type must have the same number of fields\");\n  // ...\n</code></pre> <p>It's also fine to define just the <code>from</code> method when the original class is only written, or <code>to</code> when the original class is only read:</p> <pre><code>// This can only be used for writing.\nnamespace rfl {\ntemplate &lt;&gt;\nstruct Reflector&lt;Person&gt; {\n  struct ReflType {\n    std::string first_name;\n    std::string last_name;\n  };\n\n  static ReflType from(const Person&amp; v) {\n    return {v.first_name, v.last_name};\n  }\n};\n}\n</code></pre> <p>Note that the <code>ReflType</code> does not have to be a struct. For instance, if you have a custom type called <code>MyCustomType</code> that you want to be serialized as a string, you can do the following:</p> <pre><code>namespace rfl {\ntemplate &lt;&gt;\nstruct Reflector&lt;MyCustomType&gt; {\n  using ReflType = std::string;\n\n  static MyCustomType to(const ReflType&amp; str) noexcept {\n    return MyCustomType::from_string(str);\n  }\n\n  static ReflType from(const MyCustomType&amp; v) {\n    return v.to_string();\n  }\n};\n}\n</code></pre>"},{"location":"custom_parser/#rflparsingcustomparser","title":"<code>rfl::parsing::CustomParser</code>","text":"<p>Alternatively, you can implement a custom parser using <code>rfl::parsing::CustomParser</code>.</p> <p>In order to do so, you must do the following:</p> <p>You must create a helper struct that can be parsed. The helper struct must fulfill the following conditions:</p> <p>1) It must contain a static method called <code>from_class</code> that takes your original class as an input and returns the helper struct. This method must not throw an exception. 2) (Optional) It must contain a method called <code>to_class</code> that transforms the helper struct into your original class. This method may throw an exception, if you want to. If you can directly construct your custom class from the field values in the order they were declared in the helper struct, you do not have to write a <code>to_class</code> method.</p> <p>You can then implement a custom parser for your class like this:</p> <pre><code>namespace rfl::parsing {\n\ntemplate &lt;class ReaderType, class WriterType, class ProcessorsType&gt;\nstruct Parser&lt;ReaderType, WriterType, YourOriginalClass, ProcessorsType&gt;\n    : public CustomParser&lt;ReaderType, WriterType, ProcessorsType, YourOriginalClass,\n                          YourHelperStruct&gt; {};\n\n}  // namespace rfl::parsing\n</code></pre>"},{"location":"custom_parser/#example","title":"Example","text":"<p>Suppose your original class looks like this:</p> <pre><code>struct Person {\n    Person(const std::string&amp; _first_name, const std::string&amp; _last_name,\n           const int _age)\n        : first_name_(_first_name), last_name_(_last_name), age_(_age) {}\n\n    const auto&amp; first_name() const { return first_name_; }\n\n    const auto&amp; last_name() const { return last_name_; }\n\n    auto age() const { return age_; }\n\n   private:\n    std::string first_name_;\n    std::string last_name_;\n    int age_;\n};\n</code></pre> <p>You can then write a helper struct:</p> <pre><code>struct PersonImpl {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    int age;\n\n    // 1) Static method that takes your original class as an input and\n    //    returns the helper struct.\n    //    MUST NOT THROW AN EXCEPTION!\n    static PersonImpl from_class(const Person&amp; _p) noexcept {\n        return PersonImpl{.first_name = _p.first_name(),\n                          .last_name = _p.last_name(),\n                          .age = _p.age()};\n    }\n\n    // 2) Const method called `to_class` that transforms the helper struct\n    //    into your original class.\n    //    In this case, the `to_class` method is actually optional, because\n    //    you can directly create Person from the field values.\n    Person to_class() const { return Person(first_name(), last_name(), age); }\n};\n</code></pre> <p>You then implement the custom parser:</p> <pre><code>namespace rfl::parsing {\n\ntemplate &lt;class ReaderType, class WriterType, class ProcessorsType&gt;\nstruct Parser&lt;ReaderType, WriterType, Person, ProcessorsType&gt;\n    : public CustomParser&lt;ReaderType, WriterType, ProcessorsType, Person, PersonImpl&gt; {};\n\n}  // namespace rfl::parsing\n</code></pre> <p>Now your custom class is fully supported by reflect-cpp. So for instance, you could parse it inside a vector:</p> <pre><code>const auto people = rfl::json::read&lt;std::vector&lt;Person&gt;&gt;(json_str).value();\n</code></pre> <p>As we have noted, in this particular example, the <code>Person</code> class can be constructed from the field values in <code>PersonImpl</code> in the exact same order they were declared in <code>PersonImpl</code>. So we can drop the <code>.to_class</code> method:</p> <pre><code>struct PersonImpl {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    int age;\n\n    static PersonImpl from_class(const Person&amp; _p) noexcept {\n        return PersonImpl{.first_name = _p.first_name(),\n                          .last_name = _p.last_name(),\n                          .age = _p.age()};\n    }\n};\n</code></pre>"},{"location":"custom_parser/#implement-the-parser-template","title":"Implement the <code>Parser</code> template","text":"<p>You can also directly implement the Parser template for your type. This might be beneficial when you have a third-party container type that behaves like standard containers.</p> <p>In our example, we are implementing the template for <code>gtl::flat_hash_map</code>, but the approach should also work for similar boost containers.</p> <pre><code>namespace rfl {\nnamespace parsing {\n\ntemplate &lt;class K, class V, class Hash, class KeyEqual, class Allocator&gt;\nclass is_map_like&lt;gtl::flat_hash_map&lt;K, V, Hash, KeyEqual, Allocator&gt;&gt; : public std::true_type {};\n\ntemplate &lt;class R, class W, class T, class Hash, class KeyEqual, class ProcessorsType&gt;\n  requires AreReaderAndWriter&lt;R, W, gtl::flat_hash_map&lt;std::string, T, Hash&gt;&gt;\nstruct Parser&lt;R, W, gtl::flat_hash_map&lt;std::string, T, Hash, KeyEqual&gt;, ProcessorsType&gt;\n    : public MapParser&lt;R, W, gtl::flat_hash_map&lt;std::string, T, Hash, KeyEqual&gt;, ProcessorsType&gt; {};\n\ntemplate &lt;class R, class W, typename K, typename V, class Hash, class KeyEqual, class Allocator, class ProcessorsType&gt;\n  requires AreReaderAndWriter&lt;R, W, gtl::flat_hash_map&lt;K, V, Hash, KeyEqual, Allocator&gt;&gt;\nstruct Parser&lt;R, W, gtl::flat_hash_map&lt;K, V, Hash, KeyEqual, Allocator&gt;, ProcessorsType&gt;\n    : public VectorParser&lt;R, W, gtl::flat_hash_map&lt;K, V, Hash, KeyEqual, Allocator&gt;, ProcessorsType&gt; {};\n\n}\n}\n</code></pre>"},{"location":"docs-readme/","title":"Documentation","text":""},{"location":"docs-readme/#the-basics","title":"The basics","text":"<p>Structs - Recaps the motivating example in the README. A struct is the equivalent of an AND statement or a product type in type theory.</p> <p>Optional fields - For defining fields in your serialized format that might be absent in some cases.</p> <p>Struct flattening - For making struct A \"inherit\" the fields of struct B.</p> <p>Processors - For modifying the structs before serialization and deserialization. For instance, processors can be used to transform all field names from <code>snake_case</code> to <code>camelCase</code>.</p> <p>The rfl::Field-syntax - Describes an alternative syntax which requires slightly more effort, but allows for some powerful functionalities.</p> <p>String literals - For representing strings that can only assume a limited number of enumerated values.</p> <p>Enums - Describes how reflect-cpp handles C++ enums.</p> <p>std::variant and rfl::TaggedUnion - For structs that can be one of several formats. This is the equivalent of an OR statement or a sum type in type theory.</p> <p>rfl::Box and rfl::Ref - For defining recursive structures.</p> <p>rfl::Timestamp and std::chrono::duration - For serializing and deserializing timestamps and durations.</p> <p>rfl::Skip - For skipping fields during serialization and/or deserialization.</p> <p>rfl::Result - For error handling without exceptions.</p> <p>Standard containers - Describes how reflect-cpp treats containers in the standard library.</p> <p>C arrays and inheritance - Describes how reflect-cpp handles C arrays and inheritance.</p> <p>rfl::Bytestring - Describes how reflect-cpp handles binary strings for formats that support them.</p> <p>rfl::Binary, rfl::Hex and rfl::Oct- For expressing numbers in different formats.</p>"},{"location":"docs-readme/#validation","title":"Validation","text":"<p>Regex patterns - For requiring that strings follow used-defined regex patterns.</p> <p>Validating numbers - For imposing constraints on numbers.</p> <p>Composing validators - For defining more complex validators using operators such as <code>rfl::AllOf</code> or <code>rfl::AnyOf</code>.</p> <p>Size validation - For imposing size constraints on containers such as <code>std::vector</code> or <code>std::string</code>.</p> <p>JSON schema - For validating your schema before you even send it to your C++ backend.</p>"},{"location":"docs-readme/#generic-elements","title":"Generic elements","text":"<p>rfl::Object - A map-like type representing a object with field names that are unknown at compile time.</p> <p>rfl::Generic - A catch-all type that can represent (almost) anything.</p> <p>rfl::ExtraFields - For adding extra fields to your structs, the names of which are unknown at compile time.</p>"},{"location":"docs-readme/#custom-classes","title":"Custom classes","text":"<p>Custom classes - For custom classes with private fields.</p> <p>Custom parsers for your classes - For custom classes with private fields that you want (or need) to leave absolutely untouched.</p>"},{"location":"docs-readme/#useful-helper-functions-and-classes","title":"Useful helper functions and classes","text":"<p>rfl::replace - For replacing one or several fields in a struct.</p> <p>rfl::as - For casting structs as other structs.</p> <p>rfl::NamedTuple - For structural typing.</p> <p>rfl::Tuple - An alternative to <code>std::tuple</code> that compiles more quickly.</p> <p>rfl::to_view - For accessing fields of a struct by index or name.</p>"},{"location":"docs-readme/#advanced-topics","title":"Advanced topics","text":"<p>Supporting your own format - For supporting your own serialization and deserialization formats.</p> <p>Maintaining backwards compatability - Instructions on how to ensure that your API is backwards-compatible with older versions.</p> <p>Benchmarks - Extensive benchmarks of popular libraries for serialization, deserialization.</p> <p></p>"},{"location":"enums/","title":"Enums","text":"<p>reflect-cpp supports both scoped and unscoped enumerations as long as they are named. They can either come in the form of normal enumerations or flag enums.</p>"},{"location":"enums/#normal-enumerations","title":"Normal enumerations","text":"<p>Example:</p> <pre><code>enum class Color { red, green, blue, yellow };\n\nstruct Circle {\n  float radius;\n  Color color;\n};\n\nconst auto circle = Circle{.radius = 2.0, .color = Color::green};\n\nrfl::json::write(circle);\n</code></pre> <p>This results in the following JSON string:</p> <pre><code>{\"radius\":2.0,\"color\":\"green\"}\n</code></pre> <p>However, some limitations apply:</p> <ol> <li> <p>They cannot be unnamed enumerations.</p> <pre><code>// OK - scoped enumeration\nenum class Color1 { red, green, blue, yellow };\n\n// OK - scoped enumeration\nenum struct Color2 { red, green, blue, yellow };\n\n// OK - unscoped enumeration\nenum Color3 { red, green, blue, yellow };\n\n/// Unsupported: Anonymous enumeration\nenum { red, green, blue, yellow };\n</code></pre> </li> <li> <p>Enum values must be in the range <code>[RFL_ENUM_RANGE_MIN, RFL_ENUM_RANGE_MAX]</code>. If the range is not specified, the    default range is <code>[-256, 256]</code>.</p> <ul> <li> <p>You can specify a custom range for the all enum values by defining <code>RFL_ENUM_RANGE_MIN</code> and <code>RFL_ENUM_RANGE_MAX</code>   before including the reflect-cpp header:</p> <p><pre><code>#define RFL_ENUM_RANGE_MIN -128\n#define RFL_ENUM_RANGE_MAX 128\n#include &lt;rfl.hpp&gt;\n</code></pre>     - You can specify a custom range for a specific enum by defining the specialization <code>rfl::config::enum_range</code> for       the enum type : <pre><code>enum class Color { yellow = 200, purple = 300, orange = 400 };\n\ntemplate &lt;&gt;\nstruct rfl::config::enum_range&lt;Color&gt; {\n  static constexpr int min = 200;\n  static constexpr int max = 400;\n};\n</code></pre></p> </li> </ul> </li> </ol>"},{"location":"enums/#flag-enums","title":"Flag enums","text":"<p>Sometimes the enumerations are not mutually exclusive - sticking with the metaphor of colors, it is perfectly possible for things to have more than one color. C++ programmers sometimes like to model this using a flag enum.</p> <p>Flag enums work as follows:</p> <ol> <li>The bitwise OR operator must be defined on them. If an enum has the bitwise OR operator defined on it, it will be treated as a flag enum.</li> <li>The most important values of the enum must be 1 or 2^N, N being a positive integer (in other words 1,2,4,8,16,32,...).</li> </ol> <p>Example:</p> <pre><code>// The important colors must be 1 or 2^N\nenum class Color {\n  red = 256,\n  green = 512,\n  blue = 1024,\n  yellow = 2048,\n  orange = (256 | 2048)  // red + yellow = orange\n};\n\n// The bitwise OR operator must be defined - this is how reflect-cpp knows that\n// this is a flag enum.\ninline Color operator|(Color c1, Color c2) {\n  return static_cast&lt;Color&gt;(static_cast&lt;int&gt;(c1) | static_cast&lt;int&gt;(c2));\n}\n</code></pre> <p>In this particular example, the important colors red, green, blue and yellow are all in the form of 2^N.  Other colors are ok as well, if they are expressed as combinations of the 2^N-colors. </p> <p>When something is a flag enum, then you can also do this:</p> <pre><code>const auto circle =\n    Circle{.radius = 2.0, .color = Color::blue | Color::green};\n</code></pre> <p>Which will then be represented as follows:</p> <pre><code>{\"radius\":2.0,\"color\":\"blue|green\"}\n</code></pre> <p>Using orange is fine as well:</p> <pre><code>const auto circle =\n    Circle{.radius = 2.0, .color = Color::orange};\n</code></pre> <p>But it will be represented in terms of the base colors (which are in the form 2^N):</p> <pre><code>{\"radius\":2.0,\"color\":\"red|yellow\"}\n</code></pre> <p>You can also combine orange with another color:</p> <pre><code>const auto circle =\n    Circle{.radius = 2.0, .color = Color::blue | Color::orange};\n</code></pre> <p>Which will result in this:</p> <pre><code>{\"radius\":2.0,\"color\":\"red|blue|yellow\"}\n</code></pre>"},{"location":"enums/#what-happens-if-an-enum-cannot-be-matched","title":"What happens if an enum cannot be matched?","text":"<p>If an enum cannot be matched, it will be written as an integer. This works for both normal enums as well as flag enums.</p> <p>For instance, if you use the <code>Color</code> flag enum as described in the previous section, you can do something like this:</p> <pre><code>// Enums are not supposed to be used like this, but it is defined behavior for scoped enumerations.\nconst auto circle = Circle{.radius = 2.0, .color = static_cast&lt;Color&gt;(10000)};\n</code></pre> <p>This will be represented as follows:</p> <pre><code>{\"radius\":2.0,\"color\":\"16|red|green|blue|8192\"}\n</code></pre> <p>This works, because 16 + 256 + 512 + 1024 + 8192 = 10000. Flag enums are always represented in terms of 2^N-numbers.</p>"},{"location":"enums/#general-purpose-enumeration-utilities","title":"General-purpose enumeration utilities","text":"<p>reflect-cpp also allows you to directly convert between enumerator values and strings:</p> <pre><code>enum class Color { red, green, blue };\n\nauto name = rfl::enum_to_string(Color::red);       // \"red\"\nauto value = rfl::string_to_enum&lt;Color&gt;(\"red\");    // result containing Color::red\nauto value = rfl::string_to_enum&lt;Color&gt;(\"greem\");  // error result\n</code></pre> <p>This works with normal and flag enums, and behaves just like serialization of types containing enumerations as described above.</p> <p>You can also inspect the defined enumerators of an enum type (including at compile-time):</p> <pre><code>enum class Color { red, green, blue };\n\n// This produces a named tuple where the keys are \"red\", \"green\", and \"blue\", with corresponding\n// values Color::red, Color::green, and Color::blue.\nauto enumerators_named_tuple = rfl::get_enumerators&lt;Color&gt;();\n\n// You can iterate over the enumerators like this:\nenumerators_named_tuple.apply([&amp;](const auto&amp; field) {\n  // field.name() will be \"red\", \"green\", \"blue\"\n  // field.value() will be Color::red, Color::green, Color::blue\n});\n\n// This produces the same data as an std::array containing std::pair&lt;std::string_view, Color&gt;,\n// which can be inspected at compile-time.\nconstexpr auto enumerator_array = rfl::get_enumerator_array&lt;Color&gt;();\n</code></pre> <p>In case it's more convenient to get the enumerator values as values of the enum's underlying type rather than values of the enum type itself, there is also <code>rfl::get_underlying_enumerators&lt;EnumType&gt;()</code> and <code>rfl::get_underlying_enumerator_array&lt;EnumType&gt;()</code>.</p>"},{"location":"extra_fields/","title":"<code>rfl::ExtraFields</code>","text":"<p>In some cases, you simply do not know all of the possible field names at compile time. You might know some, but you do not know all of them.</p> <p>Note that there are many ways of dealing with these kind of uncertainties, such as optional fields or tagged unions.</p> <p>But in instance where the field names are absolutely not known in advance, you might want to use <code>rfl::ExtraFields</code>:</p> <pre><code>struct Person {\n  std::string first_name;\n  std::string last_name = \"Simpson\";\n  rfl::ExtraFields&lt;rfl::Generic&gt; extra_fields;\n};\n\nauto homer = Person{.first_name = \"Homer\"};\n\nhomer.extra_fields[\"age\"] = 45;\nhomer.extra_fields[\"email\"] = \"homer@simpson.com\";\nhomer.extra_fields[\"town\"] = \"Springfield\";\n</code></pre> <p>Note that <code>rfl::ExtraFields</code> inherits from <code>rfl::Object</code> and therefore behaves exactly like it. Refer to the relevant section of the documentation on <code>rfl::Object</code>.</p> <p>This will result in the following JSON string:</p> <pre><code>{\"first_name\":\"Homer\",\"last_name\":\"Simpson\",\"age\":45,\"email\":\"homer@simpson.com\",\"town\":\"Springfield\"}\n</code></pre> <p>Likewise, when we parse the JSON string, all of the fields that can't be directly matched to a known field will be parsed into <code>extra_fields</code>.</p> <p>Note that in this particular instance, we have set the type to <code>rfl::Generic</code>. But if we know in advance that all of the extra fields must be strings, we can set it to <code>std::string</code> as well:</p> <pre><code>struct Person {\n  std::string first_name;\n  std::string last_name = \"Simpson\";\n  rfl::ExtraFields&lt;std::string&gt; extra_fields;\n};\n\nauto homer = Person{.first_name = \"Homer\"};\n\nhomer.extra_fields[\"email\"] = \"homer@simpson.com\";\nhomer.extra_fields[\"town\"] = \"Springfield\";\n</code></pre> <p>This will result in the following JSON string:</p> <pre><code>{\"first_name\":\"Homer\",\"last_name\":\"Simpson\",\"email\":\"homer@simpson.com\",\"town\":\"Springfield\"}\n</code></pre> <p>If we add an extra field that is not a string (like <code>\"age\":45</code>), this will result in a parsing error. </p>"},{"location":"flatten_structs/","title":"Flatten structs","text":"<p>In some cases, you want to structs to \"inherit\" fields from other structs. Unfortunately, doing this via actual inheritance is not possible at the moment, due to several restrictions imposed by C++.  Instead, we do it via composition, using <code>rfl::Flatten</code>.</p> <p>Note that you can also have nested flattened fields. If <code>A</code> contains <code>B</code> and <code>B</code> contains <code>C</code>, then all fields will be flattened to a single JSON object.</p> <p>If there are duplicate field names, you will get a compile-time error.</p>"},{"location":"flatten_structs/#example-every-employee-is-a-person","title":"Example: Every employee is a person","text":"<pre><code>struct Person {\n  std::string first_name;\n  std::string last_name;\n  int age;\n};\n\nstruct Employee {\n  rfl::Flatten&lt;Person&gt; person;\n  std::string employer;\n  float salary;\n};\n\nconst auto employee = Employee{\n  .person = Person{.first_name = \"Homer\",\n                   .last_name = \"Simpson\",\n                   .age = 45},\n  .employer = \"Mr. Burns\",\n  .salary = 60000.0};\n\nconst auto json_str = rfl::json::write(employee);\n</code></pre> <p>This flattens all fields into a single JSON object:</p> <pre><code>{\"first_name\":\"Homer\",\"last_name\":\"Simpson\",\"age\":45,\"salary\":60000.0}\n</code></pre>"},{"location":"flatten_structs/#example-using-the-rflfield-syntax","title":"Example, using the <code>rfl::Field</code>-syntax.","text":"<pre><code>struct Person {\n    rfl::Field&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Field&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Field&lt;\"age\", int&gt; age;\n};\n\nstruct Employee {\n    rfl::Flatten&lt;Person&gt; person;\n    rfl::Field&lt;\"salary\", float&gt; salary;\n};\n\nconst auto employee = Employee{\n    .person = Person{.first_name = \"Homer\", .last_name = \"Simpson\", .age = 45},\n    .salary = 60000.0\n};\n\nconst auto json_str = rfl::json::write(employee);\n</code></pre> <p>This flattens all fields into a single JSON object:</p> <pre><code>{\"firstName\":\"Homer\",\"lastName\":\"Simpson\",\"age\":45,\"salary\":60000.0}\n</code></pre>"},{"location":"generic/","title":"<code>rfl::Generic</code>","text":"<p>reflect-cpp is intended to be used to directly parse into structs. Doing this is more efficient, more convenient and also safer.</p> <p>But in some cases, we simply cannot anticipate the complete structure of the data at compile time. For these cases, we have <code>rfl::Generic</code>.</p> <p>Note that generics are not supported for Avro.</p> <p><code>rfl::Generic</code> is a convenience wrapper around the following type:</p> <pre><code>std::variant&lt;bool, int, double, std::string, Object, Array, std::nullopt_t&gt;;\n</code></pre> <p><code>Object</code> and <code>Array</code> are defined as follows:</p> <pre><code>using Array = std::vector&lt;Generic&gt;;\nusing Object = rfl::Object&lt;Generic&gt;;\n</code></pre> <p>In other words, <code>rfl::Generic</code> encompasses all types that can be expressed in JSON.</p> <p>It can be used as follows:</p> <pre><code>auto bart = rfl::Generic::Object();\nbart[\"first_name\"] = \"Bart\";\nbart[\"last_name\"] = \"Simpson\";\nbart[\"age\"] = 10;\n\nauto lisa = rfl::Generic::Object();\nlisa[\"first_name\"] = \"Lisa\";\nlisa[\"last_name\"] = \"Simpson\";\nlisa[\"age\"] = 8;\n\nauto maggie = rfl::Generic::Object();\nmaggie[\"first_name\"] = \"Lisa\";\nmaggie[\"last_name\"] = \"Simpson\";\nmaggie[\"age\"] = 0;\n\nauto homer = rfl::Generic::Object();\nhomer[\"first_name\"] = \"Homer\";\nhomer[\"last_name\"] = \"Simpson\";\nhomer[\"age\"] = 45;\nhomer[\"children\"] = rfl::Generic::Array({bart, lisa, maggie});\n</code></pre> <p>The resulting JSON strings looks as follows:</p> <pre><code>{\"first_name\":\"Homer\",\"last_name\":\"Simpson\",\"age\":45,\"children\":[{\"first_name\":\"Bart\",\"last_name\":\"Simpson\",\"age\":10},{\"first_name\":\"Lisa\",\"last_name\":\"Simpson\",\"age\":8},{\"first_name\":\"Lisa\",\"last_name\":\"Simpson\",\"age\":0}]}\n</code></pre> <p><code>rfl::Generic</code> contains some convenience methods that allow you to handle parsed data:</p> <p>You can retrieve the underlying <code>std::variant</code> using <code>.get()</code>. This then allows you to handle allow possible seven cases using the visitor pattern.</p> <p>If you have a guess what the types of a particular field might be, you can use any of the seven convenience methods <code>.to_array()</code>, <code>.to_bool()</code>, <code>.to_double()</code>, <code>.to_int()</code>, <code>.to_null()</code>, <code>.to_object()</code>, <code>.to_string()</code>. Each of these methods will return an <code>rfl::Result&lt;...&gt;</code> with the corresponding type, if the <code>rfl::Generic</code> does indeed contain such a type.</p> <p>If you prefer, you can also use the following seven convenience functions:</p> <p><code>rfl::to_array(...)</code>, <code>rfl::to_bool(...)</code>, <code>rfl::to_double(...)</code>, <code>rfl::to_int(...)</code>, <code>rfl::to_null</code>, <code>rfl::to_object(...)</code>, <code>rfl::to_string(...)</code>.</p> <p>These functions are particularly useful for monadic error handling:</p> <pre><code>auto homer = rfl::Generic::Object();\n...\nrfl::Result&lt;int&gt; age = homer.get(\"age\").and_then(rfl::to_int);\n</code></pre> <p>In this particular instance, we know that <code>homer</code> is an <code>rfl::Generic::Object</code>. We assume that it has a field named <code>age</code> which we also assume is an integer. In the end, we will get an <code>rfl::Result&lt;int&gt;</code> which will contain an integer, if both of our assumptions are correct and an error otherwise.</p> <p>If we want to retrieve the age, we can use the <code>.value()</code> method:</p> <pre><code>auto homer = rfl::Generic::Object();\n...\nint age = homer.get(\"age\").and_then(rfl::to_int).value();\n</code></pre> <p>This will throw an exception if any of our assumptions are false. </p> <p>Please refer to the part of the documentation on <code>rfl::Result</code> to learn more about monadic error handling.</p>"},{"location":"generic/#rflto_generic-and-rflfrom_generic","title":"<code>rfl::to_generic</code> and <code>rfl::from_generic</code>","text":"<p>You can transform any struct that can be converted to a JSON to the equivalent generic instead.</p> <p>In other words:</p> <pre><code>assert(rfl::json::write(my_struct) == rfl::json::write(rfl::to_generic(my_struct)));\n</code></pre> <p>And:</p> <pre><code>assert(rfl::json::read&lt;rfl::Generic&gt;(rfl::json::write(my_struct)).value() == rfl::to_generic(my_struct));\n</code></pre> <p>What is more, you can apply any processors you want to:</p> <pre><code>assert(rfl::json::write&lt;rfl::SnakeCaseToCamelCase&gt;(my_struct) == rfl::json::write(rfl::to_generic&lt;rfl::SnakeCaseToCamelCase&gt;(my_struct)));\n\nassert(rfl::json::read&lt;rfl::Generic&gt;(rfl::json::write&lt;rfl::SnakeCaseToCamelCase&gt;(my_struct)).value() == rfl::to_generic&lt;rfl::SnakeCaseToCamelCase&gt;(my_struct));\n</code></pre> <p>Conversely, the same statements hold for reading. In other words:</p> <pre><code>assert(rfl::json::read&lt;MyStruct&gt;(my_json_string).value() == rfl::from_generic&lt;MyStruct&gt;(rfl::json::read&lt;rfl::Generic&gt;(my_json_string).value()).value());\n</code></pre> <p>Likewise, you can apply processors:</p> <pre><code>assert(rfl::json::read&lt;MyStruct, rfl::SnakeCaseToCamelCase&gt;(my_json_string).value() == rfl::from_generic&lt;MyStruct, rfl::SnakeCaseToCamelCase&gt;(rfl::json::read&lt;rfl::Generic&gt;(my_json_string).value()).value());\n</code></pre> <p>In fact, you can think of <code>rfl::from_generic</code> and <code>rfl::to_generic</code> as manifestations of the reader and writer interface. You could as well write <code>rfl::generic::read&lt;...&gt;(...)</code> and <code>rfl::generic::write(...)</code>.</p> <p>This can be used to dynamically build structs:</p> <pre><code>struct Person {\n    std::string first_name;\n    std::string last_name;\n    int age;\n};\n\nauto bart = rfl::Generic::Object();\nbart[\"first_name\"] = \"Bart\";\nbart[\"last_name\"] = \"Simpson\";\nbart[\"age\"] = 10;\n\nconst auto person = rfl::from_generic&lt;Person&gt;(bart).value();\n</code></pre>"},{"location":"install/","title":"Installation","text":"<p>The following compilers are supported: - GCC 11.4 or higher - Clang 14.0 or higher - MSVC 17.8 (19.38) or higher</p> <p>You can include the source files into your build or compile it using cmake and vcpkg.</p>"},{"location":"install/#option-1-using-vcpkg","title":"Option 1: Using vcpkg","text":"<p>Refer to this port:</p> <pre><code>vcpkg install reflectcpp\n</code></pre> <p>or, if you are in manifest mode:</p> <pre><code>vcpkg add port reflectcpp\n</code></pre> <p>If the library cannot be found, please update vcpkg itself to make sure the newest ports are installed. You might also want to update the <code>builtin-baseline</code> tag in the vcpkg.json of your project.</p> <p>If you want to support formats other than JSON, please install the appropriate vcpkg features. Refer to the link above to find out which features are supported in the vcpkg port.</p>"},{"location":"install/#option-2-using-conan","title":"Option 2: Using Conan","text":"<p>Simply use this recipe.</p>"},{"location":"install/#option-3-compilation-using-cmake","title":"Option 3: Compilation using cmake","text":"<p>This will compile reflect-cpp with JSON support only. You can then include reflect-cpp in your project and link to the binary.</p> <pre><code>cmake -S . -B build -DCMAKE_CXX_STANDARD=20 -DCMAKE_BUILD_TYPE=Release\ncmake --build build -j 4  # gcc, clang\ncmake --build build --config Release -j 4  # MSVC\n</code></pre>"},{"location":"install/#option-4-include-source-files-into-your-own-build","title":"Option 4: Include source files into your own build","text":"<p>Simply copy the contents of the folders <code>include</code> and <code>src</code> into your source repository or add it to your include path and also add <code>src/reflectcpp.cpp</code> and <code>src/reflectcpp_json.cpp</code> and <code>src/yyjson.c</code> to your source files for compilation. If you want to link to your own version of YYJSON, then only add <code>src/reflectcpp.cpp</code> and <code>src/reflectcpp_json.cpp</code>. If you don't need JSON support, then only add <code>src/reflectcpp.cpp</code>.</p> <p>If you need support for other serialization formats like flexbuffers or XML, you should also add <code>src/reflectcpp_&lt;format&gt;.cpp</code> and include and link the respective libraries, as listed in the section on serialization formats.</p>"},{"location":"install/#option-5-compilation-using-cmake-and-vcpkg","title":"Option 5: Compilation using cmake and vcpkg","text":"<p>If you want serialization formats other than JSON, you can either install them manually or use vcpkg.</p> <p>To install vcpkg:</p> <pre><code>git submodule update --init\n./vcpkg/bootstrap-vcpkg.sh # Linux, macOS\n./vcpkg/bootstrap-vcpkg.bat # Windows\n# You may be prompted to install additional dependencies.\n</code></pre> <p>To compile the library:</p> <pre><code>cmake -S . -B build -DCMAKE_CXX_STANDARD=20 -DREFLECTCPP_AVRO=ON -DREFLECTCPP_BSON=ON -DREFLECTCPP_CAPNPROTO=ON -DREFLECTCPP_CBOR=ON -DREFLECTCPP_FLEXBUFFERS=ON -DREFLECTCPP_MSGPACK=ON -DREFLECTCPP_XML=ON -DREFLECTCPP_TOML=ON -DREFLECTCPP_UBJSON=ON -DREFLECTCPP_YAML=ON -DCMAKE_BUILD_TYPE=Release\ncmake --build build -j 4 # gcc, clang\ncmake --build build --config Release -j 4 # MSVC\n</code></pre> <p>To use reflect-cpp in your project:</p> <pre><code>add_subdirectory(reflect-cpp) # Add this project as a subdirectory\n\nset(REFLECTCPP_AVRO ON) # Optional\nset(REFLECTCPP_BSON ON) # Optional\nset(REFLECTCPP_CBOR ON) # Optional\nset(REFLECTCPP_FLEXBUFFERS ON) # Optional\nset(REFLECTCPP_MSGPACK ON) # Optional\nset(REFLECTCPP_TOML ON) # Optional\nset(REFLECTCPP_UBJSON ON) # Optional\nset(REFLECTCPP_XML ON) # Optional\nset(REFLECTCPP_YAML ON) # Optional\n\ntarget_link_libraries(your_project PRIVATE reflectcpp) # Link against the library\n</code></pre>"},{"location":"install/#troubleshooting-vcpkg","title":"Troubleshooting vcpkg","text":"<p>vcpkg is a great, but very ambitious and complex project (just like C++ is a great, but very ambitious and complex language). Here are some of the you might run into and how to resolve them:</p> <ol> <li> <p>A lot of problems can simply be resolved by deleting the build directory using <code>rm -rf build</code>.</p> </li> <li> <p>Environment variable VCPKG_FORCE_SYSTEM_BINARIES must be set on arm, s390x, ppc64le and riscv platforms. - This usually happens on arm platforms like the Apple Silicon chips and can be resolved by simply preceding your build with <code>export VCPKG_FORCE_SYSTEM_BINARIES=arm</code> or <code>export VCPKG_FORCE_SYSTEM_BINARIES=1</code>.</p> </li> <li> <p>On some occasions you might be asked to specify a compiler. You can do so by simply adding it to the cmake command as follows: <code>cmake -S . -B build ... -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++</code> or <code>cmake -S . -B build ... -DCMAKE_C_COMPILER=clang-17 -DCMAKE_CXX_COMPILER=clang++-17</code> (or whatever supported compiler you would like to use).</p> </li> </ol>"},{"location":"install/#option-6-compilation-using-conan","title":"Option 6: Compilation using Conan","text":"<p>To install Conan (assuming you have Python and pipx installed):</p> <pre><code>pipx install conan\nconan profile detect\n</code></pre> <p>For older versions of pip, you can also use <code>pip</code> instead of <code>pipx</code>.</p> <p>To install the basic (JSON-only) version, cd into the <code>reflect-cpp</code> repository and execute the following:</p> <pre><code>conan build . --build=missing -s compiler.cppstd=gnu20\n</code></pre> <p>You can call <code>conan inspect .</code> to get an overview of the supported options.</p> <p>If you want to include all formats supported on Conan, do the following:</p> <pre><code>conan build . --build=missing -s compiler.cppstd=gnu20 -o *:with_cbor=True -o *:with_flatbuffers=True -o *:with_msgpack=True -o *:with_toml=True -o *:with_ubjson=True -o *:with_xml=True -o *:with_yaml=True\n</code></pre>"},{"location":"json_schema/","title":"JSON schema","text":"<p>JSON schemata are a powerful tool for expressing the expected structure of your input. You can use it to validate your input before you even send it to your C++ backend, which will result in better UX.</p> <p>It can also be used for code generation. For instance, tools such as https://app.quicktype.io/ allow you to generate code in multiple programming languages from the JSON schema (even though the validations are usually omitted). </p> <p>If you are interacting with Python, we warmly recommend https://docs.pydantic.dev/latest/integrations/datamodel_code_generator/. This allows you to generate Pydantic dataclasses, including the validation, from the JSON schema.</p> <p>Note that this is only supported for JSON, not for other formats.</p>"},{"location":"json_schema/#basic-idea","title":"Basic idea","text":"<p>Suppose you have a struct like this:</p> <pre><code>struct Person {\n  std::string first_name;\n  std::string last_name;\n  rfl::Email email;\n  std::vector&lt;Person&gt; children;\n  float salary;\n};\n</code></pre> <p>You can generate a JSON schema like this:</p> <pre><code>const std::string json_schema = rfl::json::to_schema&lt;Person&gt;(rfl::json::pretty);\n</code></pre> <p>You do not have to pass <code>rfl::json::pretty</code>, but for the purposes of this documentation it is better to do so.</p> <p>This will result in the following JSON schema:</p> <pre><code>{\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"$ref\": \"#/definitions/Person\",\n    \"definitions\": {\n        \"Person\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"children\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"$ref\": \"#/definitions/Person\"\n                    }\n                },\n                \"email\": {\n                    \"type\": \"string\",\n                    \"pattern\": \"^[a-zA-Z0-9._%+\\\\-]+@[a-zA-Z0-9.\\\\-]+\\\\.[a-zA-Z]{2,}$\"\n                },\n                \"first_name\": {\n                    \"type\": \"string\"\n                },\n                \"last_name\": {\n                    \"type\": \"string\"\n                },\n                \"salary\": {\n                    \"type\": \"number\"\n                }\n            },\n            \"required\": [\n                \"children\",\n                \"email\",\n                \"first_name\",\n                \"last_name\",\n                \"salary\"\n            ]\n        }\n    }\n}\n</code></pre> <p>You can insert this into the tools mentioned above and see the generated code.</p>"},{"location":"json_schema/#adding-descriptions","title":"Adding descriptions","text":"<p>JSON schemata also often contain descriptions. reflect-cpp supports this as well.</p> <pre><code>struct Person {\n  std::string first_name;\n  std::string last_name;\n  rfl::Description&lt;\"Must be a proper email in the form xxx@xxx.xxx.\",\n                   rfl::Email&gt;\n      email;\n  rfl::Description&lt;\n      \"The person's children. Pass an empty array for no children.\",\n      std::vector&lt;Person&gt;&gt;\n      children;\n  float salary;\n};\n</code></pre> <pre><code>const std::string json_schema = rfl::json::to_schema&lt;Person&gt;(rfl::json::pretty);\n</code></pre> <pre><code>{\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"$ref\": \"#/definitions/Person\",\n    \"definitions\": {\n        \"Person\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"children\": {\n                    \"type\": \"array\",\n                    \"description\": \"The person's children. Pass an empty array for no children.\",\n                    \"items\": {\n                        \"$ref\": \"#/definitions/Person\"\n                    }\n                },\n                \"email\": {\n                    \"type\": \"string\",\n                    \"description\": \"Must be a proper email in the form xxx@xxx.xxx.\",\n                    \"pattern\": \"^[a-zA-Z0-9._%+\\\\-]+@[a-zA-Z0-9.\\\\-]+\\\\.[a-zA-Z]{2,}$\"\n                },\n                \"first_name\": {\n                    \"type\": \"string\"\n                },\n                \"last_name\": {\n                    \"type\": \"string\"\n                },\n                \"salary\": {\n                    \"type\": \"number\"\n                }\n            },\n            \"required\": [\n                \"children\",\n                \"email\",\n                \"first_name\",\n                \"last_name\",\n                \"salary\"\n            ]\n        }\n    }\n}\n</code></pre> <p>You also add a description to the entire JSON schema:</p> <pre><code>const std::string json_schema = rfl::json::to_schema&lt;\n    rfl::Description&lt;\"JSON schema that describes the required \"\n                      \"attributes for the person class.\",\n                      Person&gt;&gt;(rfl::json::pretty);\n</code></pre> <pre><code>{\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"$ref\": \"#/definitions/Person\",\n    \"description\": \"JSON schema that describes the required attributes for the person class.\",\n    \"definitions\": {\n        \"Person\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"children\": {\n                    \"type\": \"array\",\n                    \"description\": \"The person's children. Pass an empty array for no children.\",\n                    \"items\": {\n                        \"$ref\": \"#/definitions/Person\"\n                    }\n                },\n                \"email\": {\n                    \"type\": \"string\",\n                    \"description\": \"Must be a proper email in the form xxx@xxx.xxx.\",\n                    \"pattern\": \"^[a-zA-Z0-9._%+\\\\-]+@[a-zA-Z0-9.\\\\-]+\\\\.[a-zA-Z]{2,}$\"\n                },\n                \"first_name\": {\n                    \"type\": \"string\"\n                },\n                \"last_name\": {\n                    \"type\": \"string\"\n                },\n                \"salary\": {\n                    \"type\": \"number\"\n                }\n            },\n            \"required\": [\n                \"children\",\n                \"email\",\n                \"first_name\",\n                \"last_name\",\n                \"salary\"\n            ]\n        }\n    }\n}\n</code></pre>"},{"location":"literals/","title":"Literals","text":"<p>In many cases, when you have strings, you know in advance that these strings can only assume a limited number of values. For reasons of efficiency and safety, it is a good idea to use Literals instead of strings.</p> <p>You can declare a Literal as follows:</p> <pre><code>using MyLiteral = rfl::Literal&lt;\"option1\", \"option2\", ...&gt;;\n</code></pre> <p>You can construct literals as follows:</p> <pre><code>const auto my_literal = MyLiteral::make&lt;\"option1\"&gt;();\n</code></pre> <p>Literals that contain only one option also have a default constructor.</p> <p>Literals can be used inside switches:</p> <pre><code>switch(my_literal.value()) {\n  case MyLiteral::value_of&lt;\"option1\"&gt;():\n    ...\n\n  case MyLiteral::value_of&lt;\"option2\"&gt;():\n    ...\n\n  ...\n}\n</code></pre> <p>Literals are stored as <code>uint8_t</code> or <code>uint16_t</code> under-the-hood. But you can extract their name as a string using <code>.name()</code>  or the underlying value using <code>.value()</code>.</p> <pre><code>using MyLiteral = rfl::Literal&lt;\"option1\", \"option2\", ...&gt;;\n\nconst auto my_literal = MyLiteral::make&lt;\"option1\"&gt;();\n\n// Prints \"option1\"\nstd::cout &lt;&lt; my_literal.name() &lt;&lt; std::endl;\n\n// Prints \"0\"\nstd::cout &lt;&lt; my_literal.value() &lt;&lt; std::endl;\n</code></pre>"},{"location":"literals/#example","title":"Example","text":"<pre><code>// There are only five Simpsons.\nusing FirstName = rfl::Literal&lt;\"Homer\", \"Marge\", \"Bart\", \"Lisa\", \"Maggie\"&gt;;\n\n// All Simpsons have the last name.\nusing LastName = rfl::Literal&lt;\"Simpson\"&gt;;\n\nstruct Person {\n    rfl::Rename&lt;\"firstName\", FirstName&gt; first_name;\n    rfl::Rename&lt;\"lastName\", LastName&gt; last_name;\n    std::vector&lt;Person&gt; children;\n};\n\n// Leads to a runtime error, if the field \"lastName\" is not \"Simpson\"\n// and the field \"firstName\" is not \"Homer\", \"Marge\", \"Bart\", \"Lisa\" or \"Maggie\".\nconst auto simpson_family_member = rfl::json::read&lt;Person&gt;(some_json_string).value();\n</code></pre>"},{"location":"named_tuple/","title":"<code>rfl::NamedTuple</code>","text":"<p><code>rfl::NamedTuple</code> is very similar to <code>std::tuple</code> or <code>rfl::Tuple</code>, but unlike  these two structures, the fields have names.</p> <p>In other words, consider the following struct:</p> <pre><code>struct Person {\n    std::string first_name;\n    std::string last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n};\n</code></pre> <p>You might as well define the following <code>rfl::NamedTuple</code>:</p> <pre><code>using Person = rfl::NamedTuple&lt;\n    rfl::Field&lt;\"first_name\", std::string&gt;,\n    rfl::Field&lt;\"last_name\", std::string&gt;,\n    rfl::Field&lt;\"birthday\", rfl::Timestamp&lt;\"%Y-%m-%d\"&gt;&gt;&gt;;\n</code></pre> <p>From the point-of-view of serialization/deserialization, the two definitions are equivalent.  The resulting JSON strings (or any other format) will be the same.</p>"},{"location":"named_tuple/#structural-typing","title":"Structural typing","text":"<p>From the point-of-view of programming, there is an important difference: Structs are nominally typed and named tuples are structurally typed (confusingly, structs are not structurally typed).</p> <p>In plain language, that means that the compiler will regard this as absolutely equivalent to <code>Person</code>, the named tuple:</p> <pre><code>using Person2 = rfl::NamedTuple&lt;\n    rfl::Field&lt;\"first_name\", std::string&gt;,\n    rfl::Field&lt;\"last_name\", std::string&gt;,\n    rfl::Field&lt;\"birthday\", rfl::Timestamp&lt;\"%Y-%m-%d\"&gt;&gt;&gt;;\n</code></pre> <p>However, this will be seen as a type that is different from <code>Person</code>, the struct:</p> <pre><code>struct Person2 {\n    std::string first_name;\n    std::string last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n};\n</code></pre> <p>Structural typing also means that you can declare new types on-the-fly. For instance, in order to create a <code>Person</code> named tuple, you don't actually have to declare it at all. The following will do:</p> <pre><code>const auto person = rfl::Field&lt;\"first_name\", std::string&gt;(\"Homer\") *\n                    rfl::Field&lt;\"last_name\", std::string&gt;(\"Simpson\") *\n                    rfl::Field&lt;\"birthday\", rfl::Timestamp&lt;\"%Y-%m-%d\"&gt;&gt;(\"1987-04-19\");\n</code></pre> <p>The type of <code>person</code> will now be equivalent to the definition of <code>Person</code>, the named tuple,  regardless of whether you have actually declared it anywhere.</p> <p>On the other hand, structural typing also means that recursive definitions are impossible. For instance, consider something like this:</p> <pre><code>struct Person {\n    std::string first_name;\n    std::string last_name;\n    std::vector&lt;Person&gt; children;\n};\n</code></pre> <p>In this example, <code>Person</code> is recursively defined (because of the field <code>children</code>).  This is impossible to accomplish using structural typing and <code>rfl::NamedTuple</code>, just like it is impossible to have a recursively defined lambda function.</p>"},{"location":"named_tuple/#accessing-fields","title":"Accessing fields","text":"<p>Fields inside the named tuple can be accessed using <code>rfl::get</code> or the <code>.get</code> method:</p> <pre><code>const auto person = rfl::Field&lt;\"first_name\", std::string&gt;(\"Homer\") *\n                    rfl::Field&lt;\"last_name\", std::string&gt;(\"Simpson\") *\n                    rfl::Field&lt;\"birthday\", rfl::Timestamp&lt;\"%Y-%m-%d\"&gt;&gt;(\"1987-04-19\");\n\n// OK in most circumstances (there are restrictions\n// due to the way C++ templates work).\nconst auto first_name = person.get&lt;\"firstName\"&gt;();\n\n// Always OK\nconst auto first_name = person.template get&lt;\"firstName\"&gt;();\n\n// Always OK\nconst auto first_name = rfl::get&lt;\"firstName\"&gt;(person);\n</code></pre> <p>Fields can also be iterated over at compile-time using the <code>apply()</code> method:</p> <pre><code>auto person = rfl::Field&lt;\"first_name\", std::string&gt;(\"Bart\") *\n              rfl::Field&lt;\"last_name\", std::string&gt;(\"Simpson\");\n\nperson.apply([](const auto&amp; f) {\n  // The field name can also be obtained as a compile-time constant.\n  auto field_name = f.name();\n  const auto&amp; value = f.value();\n});\n</code></pre>"},{"location":"named_tuple/#monadic-operations-transform-and-and_then","title":"Monadic operations: <code>.transform</code> and <code>.and_then</code>","text":"<p>Named tuples also contain compile-time monadic operations. </p> <p><code>.transform(f)</code> expects a function <code>f</code> of type <code>Field -&gt; Field</code>.  <code>transform</code> then applies that function to each field of the named tuple. It can be used to change either the values or the names of the fields, but not their overall number.</p> <pre><code>const auto lisa =\n    Person{.first_name = \"Lisa\", .last_name = \"Simpson\", .age = 8};\n\nconst auto to_bart = [](auto field) {\nif constexpr (decltype(field)::name() == \"first_name\") {\n    field = \"Bart\";\n    return field;\n} else if constexpr (decltype(field)::name() == \"age\") {\n    field = 10;\n    return field;\n} else {\n    return field;\n}\n};\n\n// bart will now be a named tuple with first_name=\"Bart\",\n// last_name=\"Simpson\", age=10\nconst auto bart = rfl::to_named_tuple(lisa).transform(to_bart);\n</code></pre> <p><code>.and_then(f)</code> expects a function <code>f</code> of type <code>Field -&gt; NamedTuple</code>.  <code>and_then</code> then applies that function to each field of the named tuple and finally concatenates the resulting named tuple to form a new named tuple.  Note that the named tuple returned by <code>f</code> may be empty. <code>.and_then(f)</code> can be used  to change either the values or the names of the fields, and can also affect their overall number.</p> <pre><code>const auto lisa =\n    Person{.first_name = \"Lisa\", .last_name = \"Simpson\", .age = 8};\n\nconst auto to_bart = [](auto field) {\nif constexpr (decltype(field)::name() == \"first_name\") {\n    field = \"Bart\";\n    return rfl::make_named_tuple(field);\n} else if constexpr (decltype(field)::name() == \"age\") {\n    return rfl::make_named_tuple();\n} else {\n    return rfl::make_named_tuple(field);\n}\n};\n\n// bart will now be a named tuple with first_name=\"Bart\",\n// last_name=\"Simpson\". Since we have returned and empty\n// named tuple for the field \"age\", there will be no such\n// field in bart.\nconst auto bart = rfl::to_named_tuple(lisa).and_then(to_bart);\n</code></pre>"},{"location":"named_tuple/#rflreplace","title":"<code>rfl::replace</code>","text":"<p><code>rfl::replace</code> works for <code>rfl::NamedTuple</code> as well:</p> <pre><code>const auto lisa = rfl::Field&lt;\"firstName\", std::string&gt;(\"Lisa\") *\n                  rfl::Field&lt;\"lastName\", std::string&gt;(\"Simpson\");\n\n// Returns a deep copy of the original object,\n// replacing first_name.\nconst auto maggie =\n    rfl::replace(lisa, rfl::make_field&lt;\"firstName\"&gt;(std::string(\"Maggie\")));\n\n// Also OK\nconst auto bart = lisa.replace(rfl::make_field&lt;\"firstName\"&gt;(std::string(\"Bart\")));\n</code></pre>"},{"location":"named_tuple/#rflas","title":"<code>rfl::as</code>","text":"<p>So does <code>rfl::as</code>:</p> <pre><code>using C = rfl::NamedTuple&lt;\n    rfl::Field&lt;\"f1\", std::string&gt;,\n    rfl::Field&lt;\"f2\", std::string&gt;,\n    rfl::Field&lt;\"f4\", std::string&gt;&gt;;\n\nconst auto a = rfl::Field&lt;\"f1\", std::string&gt;(\"Hello\") *  \n               rfl::Field&lt;\"f2\", std::string&gt;(\"World\");\n\nconst auto b = rfl::Field&lt;\"f3\", std::string&gt;(\"Hello\") *  \n               rfl::Field&lt;\"f4\", std::string&gt;(\"World\");\n\nconst auto c = rfl::as&lt;C&gt;(a, b);\n</code></pre> <p>However, you do not really have to use <code>rfl::as</code> here. This will work as well:</p> <pre><code>// Same as rfl::as&lt;C&gt;(a, b)\nconst auto c = C(a * b);\n</code></pre> <p>(in fact, this is how <code>rfl::as</code> is implemented in the first place).</p>"},{"location":"named_tuple/#defining-named-tuples-using-other-named-tuples","title":"Defining named tuples using other named tuples","text":"<p><code>rfl::Flatten</code> is not supported inside named tuples. Instead, you can use <code>rfl::define_named_tuple_t&lt;...&gt;</code> to achieve the same goal:</p> <pre><code>using Person = rfl::NamedTuple&lt;\n    rfl::Field&lt;\"firstName\", std::string&gt;,\n    rfl::Field&lt;\"lastName\", std::string&gt;,\n    rfl::Field&lt;\"age\", int&gt;&gt;;\n\nusing Employee = rfl::define_named_tuple_t&lt;\n    Person,\n    rfl::Field&lt;\"salary\", float&gt;&gt;;\n\nconst auto employee = Employee(\n    rfl::Field&lt;\"firstName\", std::string&gt;(\"Homer\"),\n    rfl::Field&lt;\"lastName\", std::string&gt;(\"Simpson\"),\n    rfl::make_field&lt;\"age\"&gt;(45),\n    rfl::make_field&lt;\"salary\"&gt;(60000.0));\n</code></pre>"},{"location":"named_tuple/#transforming-structs-to-named-tuples-and-vice-versa","title":"Transforming structs to named tuples and vice versa","text":"<p>You can transform structs to named tuples and vice versa (this will only work with the <code>rfl::Field</code>-syntax:</p> <pre><code>auto bart = Person{.first_name = \"Bart\",\n                   .last_name = \"Simpson\",\n                   .birthday = \"1987-04-19\"};\n\n// bart_nt is a named tuple\nconst auto bart_nt = rfl::to_named_tuple(bart);\n\n// You can also retrieve the equivalent named tuple\n// type to a struct:\nusing PersonNamedTuple = rfl::named_tuple_t&lt;Person&gt;;\n\n// rfl::to_named_tuple also supports move semantics\nPersonNamedTuple bart_nt = rfl::to_named_tuple(std::move(bart_nt));\n\n// You can also go the other way\nconst auto bart_struct = rfl::from_named_tuple&lt;Person&gt;(bart_nt);\nconst auto bart_struct = rfl::from_named_tuple&lt;Person&gt;(std::move(bart_nt));\n</code></pre>"},{"location":"number_systems/","title":"<code>rfl::Binary</code>, <code>rfl::Hex</code> and <code>rfl::Oct</code>","text":"<p><code>rfl::Binary</code>, <code>rfl::Hex</code> and <code>rfl::Oct</code> can be used to express numbers in binary, hex and octal format.</p> <pre><code>struct ExampleStruct {\n  rfl::Binary&lt;uint8_t&gt; binary;\n  rfl::Hex&lt;int&gt; hex;\n  rfl::Oct&lt;int&gt; oct;\n};\n\nconst auto example = ExampleStruct{\n    .binary = 30,\n    .hex = 30,\n    .oct = 30};\n</code></pre> <p>This results in the following JSON:</p> <pre><code>{\"binary\":\"00011110\",\"hex\":\"1e\",\"oct\":\"36\"}\n</code></pre> <p>Note that the contained type must be integral for <code>rfl::Hex</code> and <code>rfl::Oct</code>. For <code>rfl::Binary</code>, it must be unsigned. Moreover,  the number of digits for <code>rfl::Binary</code> will be determined by the bitsize of the type.</p> <p>You can access the contained value using <code>.value()</code>, <code>.get()</code> or simply <code>operator()</code>.</p> <p>You can produce the string representation using <code>.str()</code>.</p>"},{"location":"object/","title":"<code>rfl::Object</code>","text":"<p><code>rfl::Object&lt;...&gt;</code> behaves similarly to <code>std::map&lt;std::string, ...&gt;</code> and <code>std::unordered_map&lt;std::string, ...&gt;</code>.</p> <p>It will be represented in JSON or other formats as an object:</p> <pre><code>auto bart = rfl::Object&lt;std::string&gt;();\nbart[\"first_name\"] = \"Bart\";\nbart[\"last_name\"] = \"Simpson\";\nbart[\"town\"] = \"Springfield\";\n</code></pre> <p>This is results in the following JSON string:</p> <pre><code>{\"first_name\":\"Bart\",\"last_name\":\"Simpson\",\"town\":\"Springfield\"}\n</code></pre> <p>It supports almost all of the normal features you would expect from such a container. For instance,  you can iterate through it just like any other map:</p> <pre><code>for (const auto&amp; [k, v]: bart) {\n    std::cout &lt;&lt; k &lt;&lt; \": \" &lt;&lt; v &lt;&lt; std::endl;\n}\n</code></pre> <p>However, unlike these containers, the order of fields is preserved. It is also possible to have duplicate keys:</p> <pre><code>auto bart = rfl::Object&lt;std::string&gt;();\nbart[\"first_name\"] = \"Bart\";\nbart[\"last_name\"] = \"Simpson\";\nbart[\"town\"] = \"Springfield\";\n\n// Note that you need the .insert(...) method,\n// because operator[] would overwrite the\n// existing field.\nbart.insert(\"first_name\", \"Lisa\");\n</code></pre> <p>This results in the following JSON string:</p> <pre><code>{\"first_name\":\"Bart\",\"last_name\":\"Simpson\",\"town\":\"Springfield\",\"first_name\":\"Lisa\"}\n</code></pre> <p>There are three different ways of inserting fields:</p> <ul> <li><code>operator[...]</code> creates a new field, if a field of this name doesn't already exist, and then assigns it.</li> <li><code>.insert(...)</code> inserts a new field at the end, potentially creating duplicate field names. Much like <code>std::map</code>, it supports several types of inputs:<ul> <li><code>.insert(std::pair(key, value))</code></li> <li><code>.insert(key, value)</code></li> <li><code>.insert(begin, end)</code>, where <code>begin</code> and <code>end</code> are iterators of a container of key-value-pairs</li> </ul> </li> <li><code>.emplace(...)</code> is an alias for <code>.insert</code> that exists primarily for reasons of compatability with standard containers.</li> </ul> <p>There are three different ways of accessing fields:</p> <ul> <li><code>operator[...]</code> creates a new field, if a field of this name doesn't already exist.</li> <li><code>.at(...)</code> throws an exception, if field of this name doesn't exist.</li> <li><code>.get(...)</code> returns an <code>rfl::Result</code> wrapping the field, or an <code>rfl::Error</code> if the field doesn't exist.</li> </ul> <p>Note that it is most efficient, if you access fields in the order that they were placed.</p>"},{"location":"optional_fields/","title":"Optional fields","text":"<p>Usually, when you set up a struct, all of the fields are required. For instance, in the previous example, we generated a JSON string like this:</p> <pre><code>{\"firstName\":\"Bart\",\"lastName\":\"Simpson\",\"children\":[]}\n</code></pre> <p>Likewise, if we read the JSON string and the field \"children\" is missing, that will result in a runtime error.</p> <p>But Bart doesn't have any children. After all, he's only 10 years old. To indicate to the library that the field \"children\" is optional, we can use either <code>std::optional</code>, <code>std::shared_ptr</code> or <code>std::unique_ptr</code>.</p> <p>If <code>std::optional</code> is <code>std::nullopt</code> or any of the smart pointers is a <code>nullptr</code>,  then the field will not be written to the JSON string. Likewise, when you read the JSON string, the fields will not be required. If you want the fields to be required, you can use the <code>rfl::NoOptionals</code> processor, please refer to the section on processors.</p> <p>So this is how we could rewrite the previous example:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name = \"Simpson\";\n\n    // Indicates to the library that the field is optional.\n    std::optional&lt;std::vector&lt;Person&gt;&gt; children;\n};\n\nconst auto bart = Person{.first_name = \"Bart\"};\n\nconst auto lisa = Person{.first_name = \"Lisa\"};\n\nconst auto maggie = Person{.first_name = \"Maggie\"};\n\nconst auto homer = Person{.first_name = \"Homer\",\n                          .children = std::vector&lt;Person&gt;({bart, lisa, maggie})};\n\nconst auto json_string = rfl::json::write(homer);\n</code></pre> <p>Now, the field \"children\" is missing for Bart, Lisa and Maggie:</p> <pre><code>{\"firstName\":\"Homer\",\"lastName\":\"Simpson\",\"children\":[{\"firstName\":\"Bart\",\"lastName\":\"Simpson\"},{\"firstName\":\"Lisa\",\"lastName\":\"Simpson\"},{\"firstName\":\"Maggie\",\"lastName\":\"Simpson\"}]}\n</code></pre> <p>NOTE: If you want to explicitly set default values for your fields and/or you want all fields to be optional, please consider using the <code>rfl::DefaultIfMissing</code> processor. You will find more information in the section on processors in this documentation.</p>"},{"location":"patterns/","title":"<code>rfl::Pattern</code>","text":"<p><code>rfl::Pattern</code> can be used to verify that a string fits a particular pattern, the latter of which is expressed as a regular expression.</p> <p>A common problem for backend applications or data pipelines is SQL injection. <code>rfl::Pattern</code> can be used to limit the allowed characters users are able to pass. For instance, for table names, we might only allow uppercase characters and underscores:</p> <pre><code>using TableName = rfl::Pattern&lt;R\"(^[A-Z]+(?:_[A-Z]+)*$)\", \"TableName\"&gt;;\n</code></pre> <p>Because the regex is encoded at compile time, you can be certain that whenever you use the type <code>TableName</code>, the string contained therein will fit the pattern. This is a very strong safeguard against SQL injection.</p> <p>Note that use also have to give a reasonable name to the pattern. That is, because reflect-cpp emphasizes readable error messages and regex patterns can be somewhat hard to decipher at times.</p> <p>To retrieve the underlying string, you can use the <code>.value()</code> method.</p> <p>reflect-cpp currently contains the following predefined regex patterns:</p> <ul> <li><code>rfl::AlphaNumeric</code></li> <li><code>rfl::Base64Encoded</code></li> <li><code>rfl::Email</code></li> <li><code>rfl::UUIDv1</code></li> <li><code>rfl::UUIDv2</code></li> <li><code>rfl::UUIDv3</code></li> <li><code>rfl::UUIDv4</code></li> </ul>"},{"location":"replace/","title":"<code>rfl::replace</code>","text":"<p><code>rfl::replace</code> creates a deep copy of the original struct or moves the original struct, replacing one or several fields in the process.</p> <p>This only works for the <code>rfl::Field</code>-syntax.</p> <p>In some cases, we really only want to change one or a few fields, to get from one struct to another:</p> <pre><code>const auto lisa = Person{\n    .first_name = \"Lisa\",\n    .last_name = \"Simpson\",\n    .children = std::vector&lt;Person&gt;()\n};\n\n// Returns a deep copy of the original object,\n// replacing first_name.\nconst auto maggie =\n    rfl::replace(lisa, rfl::make_field&lt;\"first_name\"&gt;(std::string(\"Maggie\")));\n</code></pre> <p><code>maggie</code> is now a deep copy of <code>lisa</code>, but with a new <code>first_name</code>.</p> <p>However, in some cases, we do not want or are unable to create a deep copy of a struct.</p> <p>For instance, suppose we had put the field <code>children</code> into a <code>rfl::Box</code>:</p> <pre><code>struct Person {\n    std::string first_name;\n    std::string last_name;\n    rfl::Box&lt;std::vector&lt;Person&gt;&gt; children;\n};\n</code></pre> <p><code>rfl::Box</code> cannot be copied, and if we naively try to apply <code>rfl::replace</code> to this, this will not compile (disabling copies is very much the point of <code>rfl::Box</code>).</p> <p>However, we can use <code>std::move</code>:</p> <pre><code>auto lisa = Person{.first_name = \"Lisa\",\n                   .last_name = \"Simpson\",\n                   .children = rfl::make_box&lt;std::vector&lt;Person&gt;&gt;()};\n\nconst auto maggie = rfl::replace(\n    std::move(lisa), rfl::make_field&lt;\"firstName\"&gt;(std::string(\"Maggie\")));\n</code></pre> <p>The fields from <code>lisa</code> have now been moved into <code>maggie</code>.</p> <p>We can also remove several fields using <code>replace</code>:</p> <pre><code>auto lisa = Person{.first_name = \"Lisa\",\n                   .last_name = \"Simpson\",\n                   .children = rfl::make_box&lt;std::vector&lt;Person&gt;&gt;()};\n\nconst auto milhouse = rfl::replace(\n    std::move(lisa),\n    rfl::make_field&lt;\"firstName\"&gt;(std::string(\"Maggie\")),\n    rfl::make_field&lt;\"lastName\"&gt;(std::string(\"Van Houten\")));\n</code></pre> <p>If you have nested structs using <code>rfl::Flatten</code>, you can treat the fields inside <code>rfl::Flatten</code> as if they were on the main level:</p> <pre><code>struct Person {\n    std::string first_name;\n    rfl::Box&lt;std::string&gt; last_name;\n    int age;\n};\n\nstruct Employee {\n    rfl::Flatten&lt;Person&gt; person;\n    rfl::Box&lt;std::string&gt; employer;\n    float salary;\n};\n\nauto employee = Employee{\n    .person = Person{.first_name = \"Homer\",\n                     .last_name = rfl::make_box&lt;std::string&gt;(\"Simpson\"),\n                     .age = 45},\n    .employer = rfl::make_box&lt;std::string&gt;(\"Mr. Burns\"),\n    .salary = 60000.0};\n\nauto employee2 =\n    rfl::replace(std::move(employee), rfl::make_field&lt;\"salary\"&gt;(70000.0),\n                 rfl::make_field&lt;\"age\"&gt;(46));\n</code></pre> <p>In this case <code>age</code> is part of <code>Person</code> and <code>salary</code> part ot <code>Employee</code>, but because you have flattened them, you can treat them as if they were on the same level.</p> <p>You can also replace structs with other structs. Consider the following example:</p> <pre><code>struct Person {\n    std::string first_name;\n    std::string last_name;\n    int age;\n};\n\nstruct Employee {\n    rfl::Flatten&lt;Person&gt; person;\n    std::string employer;\n    float salary;\n};\n\nconst auto employee = Employee{\n    .person =\n        Person{.first_name = \"Homer\", .last_name = \"Simpson\", .age = 45},\n    .employer = std::string(\"Mr. Burns\"),\n    .salary = 60000.0};\n\nconst auto carl = Person{.first_name = \"Carl\", .last_name = \"\", .age = 45};\n\nconst auto employee2 = rfl::replace(employee, carl);\n</code></pre> <p>This code flattens the employee structs and then replaces all relevant fields with their counterparts contained in <code>carl</code>.</p> <p>Finally, we get this JSON string:</p> <pre><code>{\"first_name\":\"Carl\",\"last_name\":\"\",\"age\":45,\"employer\":\"Mr. Burns\",\"salary\":60000.0}\n</code></pre> <p>Don't worry, this is fairly optimized and makes heavy use of forwarding. It does not make any copies than it absolutely has to.</p>"},{"location":"result/","title":"<code>rfl::Result</code>","text":"<p>In this documentation, we have, on several occasions, read a JSON string like this:</p> <pre><code>const auto homer = rfl::json::read&lt;Person&gt;(json_string).value();\n</code></pre> <p>However, so far we have not elaborated on why <code>.value()</code> is necessary. Why can't we just do this?</p> <pre><code>const auto homer = rfl::json::read&lt;Person&gt;(json_string);\n</code></pre> <p>The reason is that parsing a JSON string is something that might fail. We do not know much about the string that put into there. It might not be a valid JSON. And even if it is a valid JSON, then it  might not conform to the assumptions that we have made about it and laid out in the type system in the form of various structs and containers.</p> <p><code>rfl::json::read</code> handles this by returning an <code>rfl::Result</code> type. <code>rfl::Result</code> is a way of error handling without exceptions. This is needed for two reasons:</p> <p>1) Exceptions are controversial, because they add another, hidden control path to your program that it hard to follow or predict. For this reasons, and others, the Google  C++ style guide disallows exceptions altogether. Modern programming languages like Go and Rust don't even support them in the first place. The C++ standards committee has recognized this and introduced std::expected in C++-23. However, reflect-cpp is a library for C++-20 and until that changes, we need to implement our own result type.</p> <p>2) In some cases, you want to signal to the parser that is fine if some things go wrong. <code>rfl::Result</code> is the way to do that.</p> <p>If you do not care about these objections to exceptions, you can just call <code>rfl::json::read&lt;...&gt;(json_string).value()</code>, which throws an exception, if the result type contains an error and be done with it.</p> <p>Note: If you want to use <code>std::expected</code> instead of our own Result type, you can pass <code>-DREFLECTCPP_USE_STD_EXPECTED</code> during compilation. This requires C++-23 support and may not be supported on all C++ compilers.</p>"},{"location":"result/#what-is-rflresult","title":"What is <code>rfl::Result</code>?","text":"<p><code>rfl::Result</code> is similar to <code>std::optional</code> it that it contains an object that may or may not be there. However, unlike <code>std::optional</code>, it does not simply contain <code>std::nullopt</code> if the operation has not been successful. Instead, it contains an <code>rfl::Error</code> with a clear error message.</p> <p>In laying out our structs an containers, about the the type system, we are making requirements about the JSON input we are expecting from the outside world. <code>rfl::json::read&lt;T&gt;(...)</code> checks whether these requirements are met.  If the requirements are met, <code>rfl::json::read&lt;T&gt;</code> returns T wrapped inside <code>rfl::Result</code>. If they are not met, it returns <code>rfl::Error</code> containing an error message explaining what went wrong.</p>"},{"location":"result/#using-rflresult-for-parsing","title":"Using <code>rfl::Result</code> for parsing","text":"<p>Suppose you have a vector with 1000 user-supplied configurations:</p> <pre><code>const auto configs = rfl::json::read&lt;std::vector&lt;Config&gt;&gt;(json_string);\n</code></pre> <p>Chances are that the user of your software has made as mistake in at least some of these configurations. If you set it up as shown above, <code>rfl::json::read</code> will fail if one or more <code>Config</code> items contain an error. But sometimes you don't want that. Sometimes you want your software to proceed with the remaining 999 configurations and gently point out to the user that some of the configurations were faulty.</p> <p>The solution is to this instead:</p> <pre><code>const auto configs = rfl::json::read&lt;std::vector&lt;rfl::Result&lt;Config&gt;&gt;&gt;(json_string);\n</code></pre> <p>This means <code>rfl::json::read</code> is going to cut the end-users of your software some slack. But it also means that you, as the programmer, have to handle the fact that some of the configs might contain errors. </p> <p>Below, we will show you how to do that.</p>"},{"location":"result/#monadic-operations","title":"Monadic operations","text":"<p>From the point of view of category theory, <code>rfl::Result</code> is both a functor and a monad (actually, all monads are functors).</p> <p>This is reflected in its member functions <code>.transform(...)</code> and <code>.and_then(...)</code>.</p> <p><code>.transform(...)</code> requires a function <code>F</code> of the type <code>T -&gt; U</code>. If the <code>rfl::Result&lt;T&gt;</code> contains a type <code>T</code>,  then\u00a0<code>r.transform(f)</code> will return an <code>rfl::Result&lt;U&gt;</code> containing a type <code>U</code>, otherwise it will return an <code>rfl::Result&lt;U&gt;</code> containing an error.</p> <p><code>.and_then(...)</code> requires a function <code>F</code> of the type <code>T -&gt; rfl::Result&lt;U&gt;</code>. If the <code>rfl::Result&lt;T&gt;</code> contains a type <code>T</code>,  then\u00a0<code>r.and_then(f)</code> might return an <code>rfl::Result&lt;U&gt;</code> containing a type <code>U</code>, depending on whether <code>f</code> failed. If <code>r</code> already contained an error, then <code>r.and_then(f)</code> will surely return an <code>rfl::Result&lt;U&gt;</code> containing an error.</p> <p>Throughout reflect-cpp's code, these functions are widely used by the parser. For instance, consider how we are reading <code>std::unique_ptr&lt;T&gt;</code> (note that this is somewhat simplified):</p> <pre><code>const auto to_ptr = [](auto&amp;&amp; _t) {\n    return std::make_unique&lt;T&gt;(std::move(_t));\n};\n\nreturn Parser&lt;T&gt;::read(_r, _var).transform(to_ptr);\n</code></pre> <p>This code works as follows: First, we read in a type <code>T</code>, which is something that might fail. However, we know 100% that once we have <code>T</code> we can surely wrap it inside a pointer, so we can call <code>.transform(...)</code>.</p> <p>On the other hand, consider the implementation of <code>rfl::json::load</code>, which loads a JSON from a file:</p> <pre><code>template &lt;class T&gt;\nResult&lt;T&gt; load(const std::string&amp; _fname) {\n    return rfl::io::load_string(_fname).and_then(read&lt;T&gt;);\n}\n</code></pre> <p>This code works as follows: First, we read in the text file using <code>rfl::io::load_string</code>. This an operation that might fail (maybe the file doesn't exist, maybe it isn't readable, ...). Then we have to to parse its contents using <code>rfl::json::read&lt;T&gt;</code>. Again, this is an operation that might fail (might not be a proper JSON, might not conform to our requirements, ...). Therefore, we  have to call <code>.and_then(...)</code>.</p>"},{"location":"result/#retrieving-values-or-errors","title":"Retrieving values or errors","text":"<p>If you want the underlying value of type T, you can use <code>.value(...)</code>. Note that this throws an exception, if <code>rfl::Result&lt;T&gt;</code> contains an error.</p> <p>If you are 100% sure that the result does not contain error, you can also call the operator <code>*</code>. This will lead to undefined behavior, if you are wrong.</p> <p>If you want the underlying value of type T or some kind of default value, you can call <code>.value_or(your_default_value)</code>.</p> <p>If you want to retrieve the error, you can call <code>.error()</code>, which will return a value of type <code>rfl::Error</code>.</p> <p>If you want to check whether the result contains an error, you can just use the bool operator:</p> <pre><code>if (my_result) {\n  // my_result cannot contain an error,\n  // so it is okay to call operator *.\n  auto v = *my_result;\n} else {\n  // my_result must contain an error.\n  auto err = my_result.error();\n}\n</code></pre>"},{"location":"result/#rflerror","title":"<code>rfl::error</code>","text":"<p><code>rfl::error(\"error message\")</code> is a simple utility function for <code>rfl::Unexpected&lt;Error&gt;(Error(\"error message\"))</code>.</p>"},{"location":"result/#or_else-transform_error","title":"<code>.or_else(...)</code>, <code>.transform_error(...)</code>","text":"<p><code>r.or_else(f)</code> expects a function <code>f</code> for type <code>Error -&gt; rfl::Result&lt;T&gt;</code>. It returns <code>r</code> if <code>r</code> did not contain an error and the results of <code>f</code> otherwise.</p> <p><code>r.transform_error(f)</code> expects a function <code>f</code> for type <code>Error -&gt; Error</code>. </p> <p>This is often used to produce better error messages:</p> <pre><code>const auto embellish_error = [&amp;](const Error&amp; _e) -&gt; rfl::Result&lt;T&gt; {\n    return rfl::error(\"Failed to parse field '\" + key + \"': \" + _e.what());\n};\nreturn Parser&lt;T&gt;::read(_r, &amp;_var).transform_error(embellish_error);\n</code></pre>"},{"location":"rfl_ref/","title":"<code>rfl::Box</code> and <code>rfl::Ref</code>","text":"<p>In previous sections, we have defined the <code>Person</code> class recursively:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    std::vector&lt;Person&gt; children;\n};\n</code></pre> <p>This works, because <code>std::vector</code> contains a pointer under-the-hood. But what wouldn't work is something like this:</p> <pre><code>// WILL NOT COMPILE\nstruct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    Person child;\n};\n</code></pre> <p>This is because the compiler cannot figure out the intended size of the struct. But recursively defined structures are important. For instance, if you deal with machine learning, you might be familiar with a decision tree.</p> <p>A decision tree consists of a <code>Leaf</code> containing the prediction and a <code>Node</code> which splits the decision tree into two subtrees.</p> <p>A naive implementation might look like this:</p> <pre><code>// WILL NOT COMPILE\nstruct DecisionTree {\n    struct Leaf {\n        using Tag = rfl::Literal&lt;\"Leaf\"&gt;;\n        double prediction;\n    };\n\n    struct Node {\n        using Tag = rfl::Literal&lt;\"Node\"&gt;;\n        rfl::Rename&lt;\"criticalValue\", double&gt; critical_value;\n        DecisionTree lesser;\n        DecisionTree greater;\n    };\n\n    using LeafOrNode = rfl::TaggedUnion&lt;\"type\", Leaf, Node&gt;;\n\n    rfl::Field&lt;\"leafOrNode\", LeafOrNode&gt; leaf_or_node;\n};\n</code></pre> <p>Again, this will not compile, because the compiler cannot figure out the intended size of the struct.</p> <p>A possible solution might be to use <code>std::unique_ptr</code>:</p> <pre><code>// Will compile, but not an ideal design.\nstruct DecisionTree {\n    struct Leaf {\n        using Tag = rfl::Literal&lt;\"Leaf\"&gt;;\n        double prediction;\n    };\n\n    struct Node {\n        using Tag = rfl::Literal&lt;\"Node\"&gt;;\n        rfl::Rename&lt;\"criticalValue\", double&gt; critical_value;\n        std::unique_ptr&lt;DecisionTree&gt; lesser;\n        std::unique_ptr&lt;DecisionTree&gt; greater;\n    };\n\n    using LeafOrNode = rfl::TaggedUnion&lt;\"type\", Leaf, Node&gt;;\n\n    rfl::Field&lt;\"leafOrNode\", LeafOrNode&gt; leaf_or_node;\n};\n</code></pre> <p>This will compile, but the design is less than ideal. We know for a fact that a <code>Node</code> must have exactly two subtrees. But this is not reflected in the type system. In this encoding, the fields \"lesser\" and \"greater\" are marked optional and you will have to check at runtime that they are indeed set.</p> <p>But this violates the principles of reflection. Reflection is all about validating as much of our assumptions upfront as we possibly can. For a great theoretical discussion of this topic, check out Parse, don't validate by Alexis King.</p> <p>So how would we encode our assumptions that the fields \"lesser\" and \"greater\" must exist in the type system and still have code that compiles? By using <code>rfl::Box</code> instead of <code>std::unique_ptr</code>:</p> <pre><code>struct DecisionTree {\n    struct Leaf {\n        using Tag = rfl::Literal&lt;\"Leaf\"&gt;;\n        double prediction;\n    };\n\n    struct Node {\n        using Tag = rfl::Literal&lt;\"Node\"&gt;;\n        rfl::Rename&lt;\"criticalValue\", double&gt; critical_value;\n        rfl::Box&lt;DecisionTree&gt; lesser;\n        rfl::Box&lt;DecisionTree&gt; greater;\n    };\n\n    using LeafOrNode = rfl::TaggedUnion&lt;\"type\", Leaf, Node&gt;;\n\n    rfl::Field&lt;\"leafOrNode\", LeafOrNode&gt; leaf_or_node;\n};\n</code></pre> <p><code>rfl::Box</code> is a thin wrapper around <code>std::unique_ptr</code>, but it is guaranteed to never be null (unless you do something egregious such as trying to access it after calling <code>std::move</code>). It is a <code>std::unique_ptr</code> without the <code>nullptr</code>.</p> <p>If you want to learn more about the evils of null references, check out the Null References: The Billion Dollar Mistake by Tony Hoare, who invented the concept in the first place.</p> <p>You must initialize <code>rfl::Box</code> the moment you create it and it cannot be dereferenced until it is destroyed.</p> <p><code>rfl::Box</code> can be initialized using <code>rfl::make_box&lt;...&gt;(...)</code>, just like <code>std::make_unique&lt;...&gt;(...)</code>:</p> <pre><code>auto leaf1 = DecisionTree::Leaf{.value = 3.0};\n\nauto leaf2 = DecisionTree::Leaf{.value = 5.0};\n\nauto node =\n    DecisionTree::Node{.critical_value = 10.0,\n                       .lesser = rfl::make_box&lt;DecisionTree&gt;(leaf1),\n                       .greater = rfl::make_box&lt;DecisionTree&gt;(leaf2)};\n\nconst DecisionTree tree{.leaf_or_node = std::move(node)};\n\nconst auto json_string = rfl::json::write(tree);\n</code></pre> <p>This will result in the following JSON string:</p> <pre><code>{\"leafOrNode\":{\"type\":\"Node\",\"criticalValue\":10.0,\"lesser\":{\"leafOrNode\":{\"type\":\"Leaf\",\"value\":3.0}},\"greater\":{\"leafOrNode\":{\"type\":\"Leaf\",\"value\":5.0}}}}\n</code></pre> <p>You can also initialize <code>rfl::Box&lt;T&gt;</code> from a <code>std::unique_ptr&lt;T&gt;</code>:</p> <pre><code>auto ptr = std::make_unique&lt;std::string&gt;(\"Hello World!\");\nconst rfl::Result&lt;rfl::Box&lt;std::string&gt;&gt; box = rfl::make_box&lt;std::string&gt;(std::move(ptr));\n</code></pre> <p>Note that <code>box</code> is wrapped in a <code>Result</code>. That is, because we cannot guarantee at compile time that <code>ptr</code> is not <code>nullptr</code>, therefore we need to account for that.</p> <p>If you want to use reference-counted pointers, instead of unique pointers, you can use <code>rfl::Ref</code>. <code>rfl::Ref</code> is the same concept as <code>rfl::Box</code>, but using <code>std::shared_ptr</code> under-the-hood.</p> <pre><code>struct DecisionTree {\n    struct Leaf {\n        using Tag = rfl::Literal&lt;\"Leaf\"&gt;;\n        double value;\n    };\n\n    struct Node {\n        using Tag = rfl::Literal&lt;\"Node\"&gt;;\n        rfl::Rename&lt;\"criticalValue\", double&gt; critical_value;\n        rfl::Ref&lt;DecisionTree&gt; lesser;\n        rfl::Ref&lt;DecisionTree&gt; greater;\n    };\n\n    using LeafOrNode = rfl::TaggedUnion&lt;\"type\", Leaf, Node&gt;;\n\n    rfl::Field&lt;\"leafOrNode\", LeafOrNode&gt; leaf_or_node;\n};\n\nconst auto leaf1 = DecisionTree::Leaf{.value = 3.0};\n\nconst auto leaf2 = DecisionTree::Leaf{.value = 5.0};\n\nauto node =\n    DecisionTree::Node{.critical_value = 10.0,\n                       .lesser = rfl::make_ref&lt;DecisionTree&gt;(leaf1),\n                       .greater = rfl::make_ref&lt;DecisionTree&gt;(leaf2)};\n\nconst DecisionTree tree{.leaf_or_node = std::move(node)};\n\nconst auto json_string = rfl::json::write(tree);\n</code></pre> <p>The resulting JSON string is identical:</p> <pre><code>{\"leafOrNode\":{\"type\":\"Node\",\"criticalValue\":10.0,\"lesser\":{\"leafOrNode\":{\"type\":\"Leaf\",\"value\":3.0}},\"greater\":{\"leafOrNode\":{\"type\":\"Leaf\",\"value\":5.0}}}}\n</code></pre>"},{"location":"rfl_ref/#deep-copying","title":"Deep Copying","text":"<p>The default <code>rfl::Box</code> implementation behaves the same as <code>std::unique_ptr</code> in relation to copying, disabling the copy assignment operator and the copy constructor.</p> <p>An opt-in box implementation, <code>rfl::CopyableBox</code>, bypasses the <code>std::unique_ptr</code> operators and allows copying by calling the contained type's copy constructor and copy assignment operator directly, but otherwise behaves the same as <code>rfl::Box</code>.</p> <p>When using <code>rfl::CopyableBox</code>, <code>rfl::make_box&lt;...&gt;(...)</code> must be replaced with <code>rfl::make_copyable_box&lt;...&gt;(...)</code>.</p> <p>This allows for deep-copying of arbitrary-complexity types that contain nested recursive elements:</p> <pre><code>struct DecisionTree {\n    struct Leaf {\n        using Tag = rfl::Literal&lt;\"Leaf\"&gt;;\n        double prediction;\n    };\n\n    struct Node {\n        using Tag = rfl::Literal&lt;\"Node\"&gt;;\n        rfl::Rename&lt;\"criticalValue\", double&gt; critical_value;\n        rfl::CopyableBox&lt;DecisionTree&gt; lesser;\n        rfl::CopyableBox&lt;DecisionTree&gt; greater;\n    };\n\n    using LeafOrNode = rfl::TaggedUnion&lt;\"type\", Leaf, Node&gt;;\n\n    rfl::Field&lt;\"leafOrNode\", LeafOrNode&gt; leaf_or_node;\n};\n\n\nauto leaf1 = DecisionTree::Leaf{.value = 3.0};\n\nauto leaf2 = DecisionTree::Leaf{.value = 5.0};\n\nauto node =\n    DecisionTree::Node{.critical_value = 10.0,\n                       .lesser = rfl::make_copyable_box&lt;DecisionTree&gt;(leaf1),\n                       .greater = rfl::make_copyable_box&lt;DecisionTree&gt;(leaf2)};\n\nconst DecisionTree tree{.leaf_or_node = std::move(node)};\n\nauto different_leaf = DecisionTree::Leaf{.value = 1.0};\nDecisionTree copy = tree;\n\nrfl::get&lt;DecisionTree::Node&gt;(copy.leaf_or_node.get().variant()).lesser = rfl::make_copyable_box&lt;DecisionTree&gt;(different_leaf);\n</code></pre>"},{"location":"rfl_skip/","title":"<code>rfl::Skip</code>","text":"<p>It is possible to skip the serialization and deserialization of fields using <code>rfl::Skip</code>.</p> <p>Note that <code>rfl::Skip</code> is unsupported by all schemaful formats, like Avro.</p> <pre><code>struct Person {\n  rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n  rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n  rfl::Skip&lt;std::string&gt; town;\n  Age age;\n};\n</code></pre> <p>This means that the field <code>town</code> will be ignored:</p> <pre><code>{\"firstName\":\"Homer\",\"lastName\":\"Simpson\",\"age\":45}\n</code></pre> <p>If you only want to skip the deserialization, but not the serialization, you can use <code>rfl::SkipDeserialization</code>:</p> <pre><code>struct Person {\n  rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n  rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n  rfl::SkipDeserialization&lt;std::string&gt; town;\n  Age age;\n};\n</code></pre> <p>If you only want to skip the serialization, but not the deserialization, you can use <code>rfl::SkipSerialization</code>.  Note that this implies that the serializied data cannot be deserialized, because the field <code>town</code> is expected during deserialization, but not serialized.</p> <pre><code>struct Person {\n  rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n  rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n  rfl::SkipSerialization&lt;std::string&gt; town;\n  Age age;\n};\n</code></pre> <p>You can access the underlying value in the field <code>town</code> using any of the following operators:</p> <pre><code>person.town();\nperson.town.get();\nperson.town.value();\n</code></pre> <p>You can assign the underlying field just like any other field:</p> <pre><code>person.town = \"Springfield\";\n</code></pre>"},{"location":"rfl_tuple/","title":"<code>rfl::Tuple</code>","text":"<p>The problem with <code>std::tuple</code> is that it is recursively implemented. That is fine when you have a small number of elements in your tuple, but as you increase the size of the tuple, you will pay a price in terms of compile time.</p> <p>That is why reflect-cpp contains <code>rfl::Tuple</code>, which in many ways behaves  just like <code>std::tuple</code>, but it compiles considerably faster.</p> <p>The only downside of <code>rfl::Tuple</code> is that it cannot be used inside <code>constexpr</code> or <code>consteval</code> functions.</p> <p>You can use the functions <code>rfl::get</code>, <code>rfl::make_tuple</code>, <code>rfl::tuple_element_t</code>,  <code>rfl::tuple_size_v</code>, <code>rfl::tuple_cat</code> or <code>rfl::apply</code> to create or access the  tuple and they work the same way as their equivalents in the standard library. In fact, <code>std::get</code> will also work on <code>rfl::Tuple</code>.</p>"},{"location":"size_validation/","title":"<code>rfl::Size</code>","text":"<p><code>rfl::Size</code> can be used to impose constraints on any container that contains the method <code>.size()</code>, which includes <code>std::string</code>.</p> <p>For instance, you can a require a vector to be non-empty as follows:</p> <pre><code>using NonEmptyStringVector =\n    rfl::Validator&lt;std::vector&lt;std::string&gt;, rfl::Size&lt;rfl::Minimum&lt;1&gt;&gt;&gt;;\n</code></pre> <p>Or you could require it to contain exactly zero or three elements, using validator composition:</p> <pre><code>using NoneOrThree =\n    rfl::Validator&lt;std::vector&lt;std::string&gt;,\n                   rfl::Size&lt;rfl::AnyOf&lt;rfl::EqualTo&lt;0&gt;, rfl::EqualTo&lt;3&gt;&gt;&gt;&gt;;\n</code></pre>"},{"location":"standard_containers/","title":"Support for standard containers","text":"<p>The serialization and deserialization of containers is handled as follows:</p> <p><code>std::map&lt;std::string, ...&gt;</code>, <code>std::unordered_map&lt;std::string, ...&gt;</code>,  maps with any numeric types (integral and floating points) as keys, and any objects where the <code>ReflectionType</code> is either a <code>std::string</code> or a numeric type are treated as objects.</p> <p>Consider the following map:</p> <pre><code>std::map&lt;std::string, std::string&gt; homer;\nhomer[\"firstName\"] = \"Homer\";\nhomer[\"lastName\"] = \"Simpson\";\n</code></pre> <p>This will be represented as follows:</p> <pre><code>{\"firstName\":\"Homer\",\"lastName\":\"Simpson\"}\n</code></pre> <p>The same is true for numeric types:</p> <pre><code>std::map&lt;int, std::string&gt; homer;\nhomer[1] = \"Homer\";\nhomer[2] = \"Simpson\";\n</code></pre> <p>This will be represented as follows:</p> <pre><code>{\"1\":\"Homer\",\"2\":\"Simpson\"}\n</code></pre> <p>If you wrap your keys into a <code>rfl::Validator</code>, this will be treated as an object as well:</p> <pre><code>using Between1and3 = rfl::Validator&lt;int, rfl::Minimum&lt;1&gt;, rfl::Maximum&lt;3&gt;&gt;;\nstd::map&lt;Between1and3, std::string&gt; homer;\nhomer[1] = \"Homer\";\nhomer[2] = \"Simpson\";\n</code></pre> <p>This will also be represented as follows:</p> <pre><code>{\"1\":\"Homer\",\"2\":\"Simpson\"}\n</code></pre> <p>All other supported standard containers  (other than <code>std::variant</code>, <code>std::optional</code>, <code>std::unique_ptr</code> and <code>std::shared_ptr</code>)  will be represented as arrays. Containers for which the <code>value_type</code> is a key-value-pair will be represented as arrays of pairs. </p>"},{"location":"timestamps/","title":"<code>rfl::Timestamp</code> and <code>std::chrono::duration</code>","text":""},{"location":"timestamps/#rfltimestamp","title":"<code>rfl::Timestamp</code>","text":"<p><code>rfl::Timestamp</code> is a simple wrapper around <code>std::tm</code> (https://en.cppreference.com/w/cpp/chrono/c/tm).</p> <p>As its template parameter it includes the time stamp format for serialization and deserialization.</p> <p>Here is a reference for for how you can specify the format:</p> <p>https://en.cppreference.com/w/cpp/chrono/c/strftime</p> <p>In fact, <code>rfl::Timestamp</code> calls <code>strftime</code> and <code>strptime</code> under-the-hood.</p> <p>They can be used in your struct like this:</p> <pre><code>struct Person {\n  rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n};\n</code></pre> <p>An <code>rfl::Timestamp</code> can be constructed from either a string or a <code>std::tm</code> struct.</p> <pre><code>const auto person1 = Person{.birthday = \"1970-01-01\"};\nconst auto person2 = Person{.birthday = std::tm{...}};\n</code></pre> <p>You can access the underlying <code>std::tm</code> struct using the <code>.tm()</code> method and you can generate  the string representation using the <code>.str()</code> method.</p> <pre><code>const std::tm birthday = person1.birthday.tm();\nstd::cout &lt;&lt; person1.birthday.str() &lt;&lt; std::endl;\n</code></pre> <p>Note that constructing <code>rfl::Timestamp</code> from a string is convenient, but it might result in an exception.</p> <p>To avoid the exception you can also use <code>Timestamp&lt;...&gt;::from_string(...)</code>, which will return an <code>rfl::Result&lt;Timestamp&lt;...&gt;&gt;</code> or <code>rfl::Error</code>.</p> <pre><code>const rfl::Result&lt;rfl::Timestamp&lt;\"%Y-%m-%d\"&gt;&gt; result = rfl::Timestamp&lt;\"%Y-%m-%d\"&gt;::from_string(\"1970-01-01\");\nconst rfl::Result&lt;rfl::Timestamp&lt;\"%Y-%m-%d\"&gt;&gt; error = rfl::Timestamp&lt;\"%Y-%m-%d\"&gt;::from_string(\"not a proper time format\");\n</code></pre>"},{"location":"timestamps/#stdchronoduration","title":"<code>std::chrono::duration</code>","text":"<p><code>std::chrono::duration</code> types are serialized as an object with the count and unit as fields:</p> <pre><code>struct MyStruct {\n  std::chrono::seconds duration;\n};\nrfl::json::write(MyStruct{.duration = std::chrono::seconds(10)});\n</code></pre> <p>This results in the following JSON:</p> <pre><code>{\"duration\":{\"count\":10,\"unit\":\"seconds\"}}\n</code></pre> <p>Units are automatically transformed upon reading. For instance, both of the JSON snippets below can be read into <code>MyStruct</code>, and both yield equivalent results:</p> <pre><code>{\"duration\":{\"count\":600,\"unit\":\"seconds\"}}\n</code></pre> <pre><code>{\"duration\":{\"count\":10,\"unit\":\"minutes\"}}\n</code></pre> <p>The second JSON snippet, encoded in minutes, will be transformed to seconds.</p> <p>The following units are supported: <code>std::chrono::nanoseconds</code>, <code>std::chrono::microseconds</code>, <code>std::chrono::milliseconds</code>, <code>std::chrono::seconds</code>,  <code>std::chrono::minutes</code>, <code>std::chrono::hours</code>, <code>std::chrono::days</code>, <code>std::chrono::weeks</code>, <code>std::chrono::months</code>, and <code>std::chrono::years</code>.</p>"},{"location":"to_view/","title":"<code>rfl::to_view</code>","text":"<p><code>rfl::to_view</code> allows you to create views on structs using which you can access an modify the fields of the structs just like a tuple.</p> <p>Under-the-hood, a view is a <code>rfl::NamedTuple</code> containing pointers to the original fields.</p> <p>For example:</p> <pre><code>auto lisa = Person{.first_name = \"Lisa\", .last_name = \"Simpson\", .age = 8};\n\nconst auto view = rfl::to_view(lisa);\n\n// Assigns the first field, thus modifying the struct 'lisa'.\n*view.get&lt;0&gt;() = \"Maggie\";\n\n// view.values() is a std::tuple containing\n// pointers to the original fields.\n*std::get&lt;1&gt;(view.values()) = \"Simpson\";\n\n// You can also access fields by their name.\n// The correctness will be ensured at compile time.\n*view.get&lt;\"age\"&gt;() = 0;\n\n// You can also access fields like this.\n*rfl::get&lt;0&gt;(view) = \"Maggie\";\n\n// Or like this.\n*rfl::get&lt;\"first_name\"&gt;(view) = \"Maggie\";\n</code></pre>"},{"location":"validating_numbers/","title":"Validating numbers","text":"<p>reflect-cpp can also be used to impose condition on numbers. For instance,  if you want an integer that is greater or equal to 10, you can do the following:</p> <pre><code>using IntGreaterThan10 = rfl::Validator&lt;int, rfl::Minimum&lt;10&gt;&gt;;\n</code></pre> <p>When you then use the type <code>IntGreaterThan10</code> inside you <code>rfl::Field</code>, the condition will be automatically validated.</p> <p>The underlying value can be retrieved using the <code>.value()</code> method.</p> <p>The current conditions are currently supported by reflect-cpp:</p> <ul> <li><code>rfl::EqualTo</code></li> <li><code>rfl::NotEqualTo</code></li> <li><code>rfl::Minimum</code></li> <li><code>rfl::ExclusiveMinimum</code></li> <li><code>rfl::Maximum</code></li> <li><code>rfl::ExclusiveMaximum</code></li> </ul>"},{"location":"variants_and_tagged_unions/","title":"<code>std::variant</code>, <code>rfl::Variant</code> and <code>rfl::TaggedUnion</code>","text":""},{"location":"variants_and_tagged_unions/#rflvariant-untagged","title":"<code>rfl::Variant</code> (untagged)","text":"<p>Sometimes you know that the JSON object can be one of several alternatives. For example, you might have several shapes like <code>Circle</code>, <code>Rectangle</code> or <code>Square</code>. For these kind of  cases, the C++ standard library contains <code>std::variant</code> and it is supported by reflect-cpp. </p> <p>However, we recommend you use <code>rfl::Variant</code> instead.</p> <p><code>rfl::Variant</code> behaves just like <code>std::variant</code>, but it compiles considerably faster, particularly for variants with many alternatives.</p> <p>You can use the functions <code>rfl::get</code>, <code>rfl::get_if</code>, <code>rfl::holds_alternative</code>, <code>rfl::visit</code>,  <code>rfl::variant_alternative_t</code> and <code>rfl::variant_size_v</code> to access the variant and they work the same way as their equivalents in the standard library.</p> <pre><code>struct Circle {\n  double radius;\n};\n\nstruct Rectangle {\n  double height;\n  double width;\n};\n\nstruct Square {\n  double width;\n};\n\nusing Shapes = rfl::Variant&lt;Circle, Rectangle, Square&gt;;\n\nconst Shapes r = Rectangle{.height = 10, .width = 5};\n\nconst auto json_string = rfl::json::write(r);\n\nconst auto r2 = rfl::json::read&lt;Shapes&gt;(json_string);\n</code></pre> <p>This code will compile just fine and work as intended. However, there are several problems with this:</p> <p>1) It is in inefficient: The parser has to read the fields for all of the different alternatives until it can't find a required field in the JSON object. It will then move on to the next alternative. 2) It leads to confusing error messages: If none of the alternatives can be matched, you will get an error message telling you why each of the alternatives couldn't be matched. Such error messages are very long-winding and hard to read. 3) It is dangerous. Imagine we had written <code>rfl::Variant&lt;Circle, Square, Rectangle&gt;</code> instead of <code>rfl::Variant&lt;Circle, Rectangle, Square&gt;</code>. This would mean that <code>Rectangle</code> could never be matched, because the fields in <code>Square</code> are a subset of <code>Rectangle</code>. This leads to very confusing bugs.</p>"},{"location":"variants_and_tagged_unions/#automatic-tags","title":"Automatic tags","text":"<p>The easiest way to solve this problem is to simply add tags automatically. You can do so by using <code>rfl::AddTagsToVariants</code>:</p> <pre><code>const auto json_string = rfl::json::write&lt;rfl::AddTagsToVariants&gt;(r);\n\nconst auto r2 = rfl::json::read&lt;Shapes, rfl::AddTagsToVariants&gt;(json_string);\n</code></pre> <p>Please refer to the section on processors in this documentation for more information.</p>"},{"location":"variants_and_tagged_unions/#rfltaggedunion-internally-tagged","title":"<code>rfl::TaggedUnion</code> (internally tagged)","text":"<p>Another way to solve this problem is to add a tag inside the class. That is why we have provided a helper class for these purposes: <code>rfl::TaggedUnion</code>.</p> <p>TaggedUnions use the name of the struct as an identifying tag. It will then try to take that field from the JSON object, match it to the correct alternative and then only parse the correct alternative.</p> <p>We will now rewrite the example from above using <code>rfl::TaggedUnion</code>:</p> <pre><code>struct Circle {\n  double radius;\n};\n\nstruct Rectangle {\n  double height;\n  double width;\n};\n\nstruct Square {\n  double width;\n};\n\n// Now you tell rfl::TaggedUnion that you want it to write the name\n// of the struct into an extra field called \"shape\".\nusing Shapes = rfl::TaggedUnion&lt;\"shape\", Circle, Square, Rectangle&gt;;\n\nconst Shapes r = Rectangle{.height = 10, .width = 5};\n\nconst auto json_string = rfl::json::write(r);\n\nconst auto r2 = rfl::json::read&lt;Shapes&gt;(json_string);\n</code></pre> <p>The resulting JSON looks like this: <pre><code>{\"shape\":\"Rectangle\",\"height\":10.0,\"width\":5.0}\n</code></pre></p> <p>Because the tag is inside the JSON object, this is called internally tagged.  It is the standard in Python's pydantic.</p> <p>It is also possible to set the tag explicitly:</p> <pre><code>struct Circle {\n  using Tag = rfl::Literal&lt;\"circle\", \"Circle\"&gt;;\n  double radius;\n};\n\nstruct Rectangle {\n  using Tag = rfl::Literal&lt;\"rectangle\", \"Rectangle\"&gt;;\n  double height;\n  double width;\n};\n\nstruct Square {\n  using Tag = rfl::Literal&lt;\"square\", \"Square\"&gt;;\n  double width;\n};\n\nusing Shapes = rfl::TaggedUnion&lt;\"shape\", Circle, Square, Rectangle&gt;;\n\nconst Shapes r = Rectangle{.height = 10, .width = 5};\n\nconst auto json_string = rfl::json::write(r);\n\nconst auto r2 = rfl::json::read&lt;Shapes&gt;(json_string);\n</code></pre> <p>The JSON generated by <code>rfl::json::write</code> looks like this:</p> <pre><code>{\"shape\":\"rectangle\",\"height\":10.0,\"width\":5.0}\n</code></pre> <p>However, <code>rfl::json::read</code> would also accept this:</p> <pre><code>{\"shape\":\"Rectangle\",\"height\":10.0,\"width\":5.0}\n</code></pre> <p>If the behavior of your program depends on the value the user has decided to pass, then you can also set the tag as a field explicitly. </p> <p>For instance, if it somehow makes a difference whether the JSON contains \"Rectangle\" or \"rectangle\", you can do the following:</p> <pre><code>struct Circle {\n  rfl::Literal&lt;\"circle\", \"Circle\"&gt; shape;\n  double radius;\n};\n\nstruct Rectangle {\n  rfl::Literal&lt;\"rectangle\", \"Rectangle\"&gt; shape;\n  double height;\n  double width;\n};\n\nstruct Square {\n  rfl::Literal&lt;\"square\", \"Square\"&gt; shape;\n  double width;\n};\n\nusing Shapes = rfl::TaggedUnion&lt;\"shape\", Circle, Square, Rectangle&gt;;\n\nconst Shapes r = Rectangle{\n  .shape = rfl::Literal&lt;\"rectangle\", \"Rectangle\"&gt;::make&lt;\"Rectangle\"&gt;(),\n  .height = 10,\n  .width = 5};\n\nconst auto json_string = rfl::json::write(r);\n\nconst auto r2 = rfl::json::read&lt;Shapes&gt;(json_string);\n</code></pre> <p>Note that in this case the type of the field <code>shape</code> MUST be <code>rfl::Literal</code>. Also note that this is exactly how tagged unions work in Pydantic. When you  use the <code>rfl::NoFieldNames</code> processor, the tag MUST always be the first entry  of the array.</p>"},{"location":"variants_and_tagged_unions/#stdvariant-or-rflvariant-externally-tagged","title":"<code>std::variant</code> or <code>rfl::Variant</code> (externally tagged)","text":"<p>Another approach is to add external tags. </p> <p>You can do that using <code>rfl::Field</code>:</p> <pre><code>using TaggedVariant = rfl::Variant&lt;rfl::Field&lt;\"option1\", Type1&gt;, rfl::Field&lt;\"option2\", Type2&gt;, ...&gt;;\n</code></pre> <p>The parser can now figure this out and will only try to parse the field that was indicated by the field name. Duplicate field names will lead to compile-time errors.</p> <p>We can rewrite the example from above:</p> <pre><code>// Circle, Rectangle and Square are the same as above.\nusing Shapes = rfl::Variant&lt;rfl::Field&lt;\"circle\", Circle&gt;,\n                            rfl::Field&lt;\"rectangle\", Rectangle&gt;,\n                            rfl::Field&lt;\"square\", Square&gt;&gt;;\n\nconst Shapes r =\n    rfl::make_field&lt;\"rectangle\"&gt;(Rectangle{.height = 10, .width = 5});\n\nconst auto json_string = rfl::json::write(r);\n\nconst auto r2 = rfl::json::read&lt;Shapes&gt;(json_string);\n</code></pre> <p>The resulting JSON looks like this: <pre><code>{\"rectangle\":{\"height\":10.0,\"width\":5.0}}\n</code></pre></p> <p>Because the tag is external, this is called externally tagged. It is the standard in Rust's serde-json.</p>"},{"location":"variants_and_tagged_unions/#the-visitor-pattern","title":"The visitor pattern","text":"<p>In C++, the idiomatic way to handle <code>std::variant</code>, <code>rfl::Variant</code> and <code>rfl::TaggedUnion</code> is the visitor pattern.</p> <p>For instance, the externally tagged <code>rfl::Variant</code> from the example above could be handled like this:</p> <pre><code>using Shapes = rfl::Variant&lt;rfl::Field&lt;\"circle\", Circle&gt;,\n                            rfl::Field&lt;\"rectangle\", Rectangle&gt;,\n                            rfl::Field&lt;\"square\", Square&gt;&gt;;\n\nconst Shapes my_shape =\n    rfl::make_field&lt;\"rectangle\"&gt;(Rectangle{.height = 10, .width = 5});\n\nconst auto handle_shapes = [](const auto&amp; field) {\n  using Name = typename std::decay_t&lt;decltype(field)&gt;::Name;\n  if constexpr (std::is_same&lt;Name, rfl::Literal&lt;\"circle\"&gt;&gt;()) {\n     std::cout &lt;&lt; is circle, radius: &lt;&lt; field.value().radius() &lt;&lt; std::endl;\n  } else if constexpr (std::is_same&lt;Name, rfl::Literal&lt;\"rectangle\"&gt;&gt;()) {\n     std::cout &lt;&lt; is rectangle, width: &lt;&lt; field.value().width() &lt;&lt; \", height: \" &lt;&lt; field.value().height() &lt;&lt; std::endl;\n  } else if constexpr (std::is_same&lt;Name, rfl::Literal&lt;\"square\"&gt;&gt;()) {\n     std::cout &lt;&lt; is square, width: &lt;&lt; field.value().width() &lt;&lt; std::endl;\n  } else {\n    // reflect-cpp also provides this very useful helper that ensures\n    // at compile-time that you didn't forget anything.\n    static_assert(rfl::always_false_v&lt;Type&gt;, \"Not all cases were covered.\");\n  }\n};\n\nrfl::visit(handle_shapes, my_shape); // OK\n\nmy_shape.visit(handle_shapes); // also OK\n</code></pre> <p>You can also apply <code>rfl::visit</code> to <code>rfl::TaggedUnion</code>. The underlying <code>rfl::Variant</code> can be retrieved using <code>.variant()</code>:</p> <pre><code>using Shapes = rfl::TaggedUnion&lt;\"shape\", Circle, Square, Rectangle&gt;;\n\nconst Shapes my_shape = Rectangle{.height = 10, .width = 5};\n\nconst auto handle_shapes = [](const auto&amp; s) {\n  using Type = std::decay_t&lt;decltype(s)&gt;;\n  if constexpr (std::is_same&lt;Type, Circle&gt;()) {\n     std::cout &lt;&lt; is circle, radius: &lt;&lt; s.radius() &lt;&lt; std::endl;\n  } else if constexpr (std::is_same&lt;Type, Rectangle&gt;()) {\n     std::cout &lt;&lt; is rectangle, width: &lt;&lt; s.width() &lt;&lt; \", height: \" &lt;&lt; s.height() &lt;&lt; std::endl;\n  } else if constexpr (std::is_same&lt;Type, Square&gt;()) {\n     std::cout &lt;&lt; is square, width: &lt;&lt; s.width() &lt;&lt; std::endl;\n  } else {\n    static_assert(rfl::always_false_v&lt;Type&gt;, \"Not all cases were covered.\");\n  }\n};\n\nrfl::visit(handle_shapes, my_shape); // OK\n\nmy_shape.visit(handle_shapes); // also OK\n</code></pre>"},{"location":"concepts/custom_classes/","title":"Custom classes","text":"<p>Reflection implies that all your fields are public. But in object-oriented programming, you often don't want that. If your class is more than a trivial, behaviorless struct, you often want to make your fields private.</p> <p>If you want your class to be supported by reflect-cpp, it needs to have the following:</p> <p>1) It needs to publicly define a type called <code>ReflectionType</code> using <code>using</code> or <code>typedef</code>. 2) It needs to have a constructor that accepts your <code>ReflectionType</code> as an argument. 3) It needs to contain a method called <code>reflection</code> that returns said <code>ReflectionType</code> (or a reference thereto).</p> <p>If you class fulfills these three conditions, then it is fully supported by all serialization and deserialization routines in reflect-cpp.</p> <p>Please be aware that due to limitations of the Avro format, it is a good idea to always have a struct as your <code>ReflectionType</code> when using Avro to avoid infinite recursions.</p> <p>If you absolutely do not want to make any changes to your original class, you can implement a custom parser.</p>"},{"location":"concepts/custom_classes/#example-1-using-an-impl-struct","title":"Example 1: Using an Impl struct","text":"<pre><code>struct PersonImpl {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    int age;\n};\n\nclass Person {\n    public:\n      // 1) Publicly define `ReflectionType`\n      using ReflectionType = PersonImpl;\n\n      // 2) Constructor that accepts your `ReflectionType`\n      Person(const PersonImpl&amp; _impl): impl(_impl) {}\n\n      ~Person() = default;\n\n      // 3) Method called `reflection` that returns `ReflectionType`\n      const ReflectionType&amp; reflection() const { return impl; }\n\n      // ...add some more methods here...\n\n    private:\n        PersonImpl impl;\n};\n</code></pre>"},{"location":"concepts/custom_classes/#example-2-matching-variables-the-safe-way","title":"Example 2: Matching variables, the safe way","text":"<p><code>rfl::Field</code> is designed in a way that you have to explicitly initialize every the field (using <code>rfl::default_value</code>, if necessary), otherwise you will get a compile-time error. </p> <p>A frequent error that happens during serialization/deserialization is that programmers add a field to their class (<code>Person</code> in this example), but forget to update their serialization routine.</p> <p>The example as shown below will protect you from any such errors, as all  fields will have to be explicitly initialized, otherwise you will get a  compile-time error. If you add a new field to <code>Person</code> you will have to add it to <code>PersonImpl</code> as well and then explicitly initialize it in the  constructor.</p> <p>Don't worry <code>operator()</code> in <code>rfl::Field</code> is inlined. There won't be any  runtime overhead.</p> <pre><code>struct PersonImpl {\n    rfl::Field&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Field&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Field&lt;\"age\", int&gt; age;\n};\n\nclass Person {\n    public:\n      // 1) Publicly define `ReflectionType`\n      using ReflectionType = PersonImpl;\n\n      // 2) Constructor that accepts your `ReflectionType`\n      // This as the additional benefit that not only the types,\n      // but also the names of the fields will be checked at compile time.\n      Person(const PersonImpl&amp; _impl): first_name(_impl.first_name),\n          last_name(_impl.last_name), age(_impl.age) {}\n\n      ~Person() = default;\n\n      // 3) Method called `reflection` that returns `ReflectionType`\n      ReflectionType reflection() const {\n          return PersonImpl{\n            .first_name = first_name,\n            .last_name = last_name,\n            .age = age};\n      }\n\n      // ...add some more methods here...\n\n    private:\n      rfl::Field&lt;\"firstName\", std::string&gt; first_name;\n      rfl::Field&lt;\"lastName\", std::string&gt; last_name;\n      rfl::Field&lt;\"age\", int&gt; age;\n};\n</code></pre>"},{"location":"concepts/custom_classes/#example-3-matching-variables-the-unsafe-way","title":"Example 3: Matching variables, the unsafe way","text":"<p>If, for any reason, you absolutely cannot change the fields of your class, you have to make sure that all classes are properly initialized or face runtime errors.</p> <pre><code>struct PersonImpl {\n    // ... same as in Example 1 or 2\n};\n\nclass Person {\n    // 1) Publicly define `ReflectionType`\n    using ReflectionType = PersonImpl;\n\n    // 2) Constructor that accepts your `ReflectionType`\n    Person(const PersonImpl&amp; _impl): first_name(_impl.first_name()),\n        last_name(_impl.last_name()), age(_impl.age()) {}\n\n    // ... same as in Example 2\n\n    private:\n      std::string first_name;\n      std::string last_name;\n      int age;\n};\n</code></pre>"},{"location":"concepts/field_syntax/","title":"The <code>rfl::Field</code>-syntax","text":"<p>As we have shown, reflect-cpp can automatically retrieve field names from structs.</p> <p>However, it also possible to annotate the fields using <code>rfl::Field</code>, like this:</p> <pre><code>struct Person {\n    rfl::Field&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Field&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Field&lt;\"children\", std::vector&lt;Person&gt;&gt; children;\n};\n</code></pre> <p>These annotations are required if you are planning to use a compiler other than MSVC, GCC or clang.</p> <p>There are a two things you have to keep in mind:</p> <p>1) If you annotate some of the fields using <code>rfl::Field</code>, then you must annotate all of them. 2) If you are combining structs using <code>rfl::Flatten</code>, then they structs combined like this must either be annotated or not.</p> <p>You can initilize your struct like this:</p> <pre><code>const auto bart = Person{.first_name = \"Bart\",\n                         .last_name = \"Simpson\",\n                         .children = std::vector&lt;Person&gt;()};\n</code></pre> <p>Note that all fields must be explicitly set. This is on purpose, because it prevents you from accidentally forgetting fields, which can lead to tricky runtime errors.</p> <p>You can initialize a field using <code>rfl::default_value</code>:</p> <pre><code>const auto bart = Person{.first_name = \"Bart\",\n                         .last_name = \"Simpson\",\n                         .children = rfl::default_value};\n</code></pre> <p>You can also initialize fields in the struct declaration itself:</p> <pre><code>struct Person {\n    rfl::Field&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Field&lt;\"lastName\", std::string&gt; last_name = \"Simpson\";\n    rfl::Field&lt;\"children\", std::vector&lt;Person&gt;&gt; children = rfl::default_value;\n};\n</code></pre> <p>Because you now have explicitly set those fields, you do not have to do this every time:</p> <pre><code>const auto bart = Person{.first_name = \"Bart\"};\n\nconst auto lisa = Person{.first_name = \"Lisa\"};\n\nconst auto maggie = Person{.first_name = \"Maggie\"};\n\nconst auto homer = Person{.first_name = \"Homer\",\n                          .children = std::vector&lt;Person&gt;({bart, lisa, maggie})};\n</code></pre> <p>You can write this to a JSON string:</p> <pre><code>const auto json_string = rfl::json::write(homer);\n</code></pre> <pre><code>{\"firstName\":\"Homer\",\"lastName\":\"Simpson\",\"children\":[{\"firstName\":\"Bart\",\"lastName\":\"Simpson\",\"children\":[]},{\"firstName\":\"Lisa\",\"lastName\":\"Simpson\",\"children\":[]},{\"firstName\":\"Maggie\",\"lastName\":\"Simpson\",\"children\":[]}]}\n</code></pre> <p>And you can parse it back into a struct:</p> <pre><code>const auto homer = rfl::json::read&lt;Person&gt;(json_string).value();\n</code></pre>"},{"location":"concepts/processors/","title":"Processors","text":"<p>Processors can be used to apply transformations to struct serialization and deserialization.</p> <p>For instance, C++ usually uses <code>snake_case</code>, but JSON uses <code>camelCase</code>. One way to handle this is <code>rfl::Rename</code>, but a more automated way would be to use a processor:</p> <pre><code>struct Person {\n    std::string first_name;\n    std::string last_name;\n    std::vector&lt;Person&gt; children;\n};\n\nconst auto homer =\n    Person{.first_name = \"Homer\",\n           .last_name = \"Simpson\",\n           .age = 45};\n\nconst auto json_string = \n  rfl::json::write&lt;rfl::SnakeCaseToCamelCase&gt;(homer);\n\nconst auto homer2 = \n  rfl::json::read&lt;Person, rfl::SnakeCaseToCamelCase&gt;(json_string).value();\n</code></pre> <p>The resulting JSON string looks like this:</p> <pre><code>{\"firstName\":\"Homer\",\"lastName\":\"Simpson\",\"age\":45}\n</code></pre>"},{"location":"concepts/processors/#supported-processors","title":"Supported processors","text":"<p>reflect-cpp currently supports the following processors:</p> <ul> <li><code>rfl::AddStructName</code> </li> <li><code>rfl::AddTagsToVariants</code> </li> <li><code>rfl::AllowRawPtrs</code> </li> <li><code>rfl::DefaultIfMissing</code> </li> <li><code>rfl::NoExtraFields</code> </li> <li><code>rfl::NoFieldNames</code> </li> <li><code>rfl::NoOptionals</code> </li> <li><code>rfl::UnderlyingEnums</code> </li> <li><code>rfl::SnakeCaseToCamelCase</code> </li> <li><code>rfl::SnakeCaseToPascalCase</code> </li> </ul>"},{"location":"concepts/processors/#rfladdstructname","title":"<code>rfl::AddStructName</code>","text":"<p>It is also possible to add the struct name as an additional field, like this:</p> <pre><code>const auto json_string = \n  rfl::json::write&lt;rfl::AddStructName&lt;\"type\"&gt;&gt;(homer);\n\nconst auto homer2 = \n  rfl::json::read&lt;Person, rfl::AddStructName&lt;\"type\"&gt;&gt;(json_string).value();\n</code></pre> <p>The resulting JSON string looks like this:</p> <pre><code>{\"type\":\"Person\",\"first_name\":\"Homer\",\"last_name\":\"Simpson\",\"age\":45}\n</code></pre>"},{"location":"concepts/processors/#rfladdtagstovariants","title":"<code>rfl::AddTagsToVariants</code>","text":"<p>This processor automatically adds tags to variants. Consider the following example:</p> <pre><code>struct button_pressed_t {};\n\nstruct button_released_t {};\n\nstruct key_pressed_t {\n  char key;\n};\n\nusing my_event_type_t =\n    std::variant&lt;button_pressed_t, button_released_t, key_pressed_t, int&gt;;\n</code></pre> <p>The problem here is that <code>button_pressed_t</code> and <code>button_released_t</code> virtually look indistinguishable when they are serialized. The will both be serialized to <code>{}</code>.</p> <p>But you can add this processor to automatically add tags and avoid the problem:</p> <pre><code>const auto vec = std::vector&lt;my_event_type_t&gt;(\n  {button_pressed_t{}, button_released_t{}, key_pressed_t{'c'}, 3});\n\nconst auto json_string = rfl::json::write&lt;rfl::AddTagsToVariants&gt;(vec);\n\nrfl::json::write&lt;std::vector&lt;my_event_type_t&gt;, rfl::AddTagsToVariants&gt;(json_string);\n</code></pre> <p><code>vec</code> will now be serialized as follows:</p> <pre><code>[{\"button_pressed_t\":{}},{\"button_released_t\":{}},{\"key_pressed_t\":{\"key\":99}},{\"int\":3}]\n</code></pre> <p>You can also set your own custom tags like this:</p> <pre><code>struct key_pressed_t {\n  using Tag = rfl::Literal&lt;\"your_custom_tag\"&gt;;\n  char key;\n};\n</code></pre> <p><code>key_pressed_t</code> will now be serialized as follows:</p> <pre><code>{\"your_custom_tag\":{\"key\":99}}\n</code></pre> <p>Note that there are other ways to address problems like this, for instance <code>rfl::TaggedUnion</code>. Please refer to the relevant sections of the documentation.</p>"},{"location":"concepts/processors/#rflallowrawptrs","title":"<code>rfl::AllowRawPtrs</code>","text":"<p>By default, reflect-cpp does not allow reading into raw pointers, <code>std::string_view</code> or <code>std::span</code>.  (Writing from raw pointers is never a problem.) This is because reading into raw pointers  means that the library will allocate memory that the user then has to manually delete. This can lead to misunderstandings and memory leaks.</p> <p>You might want to consider using some alternatives, such as <code>std::unique_ptr</code>, <code>rfl::Box</code>,  <code>std::shared_ptr</code>, <code>rfl::Ref</code> or <code>std::optional</code>.  But if you absolutely have to use raw pointers, you can pass <code>rfl::AllowRawPtrs</code> to <code>read</code>:</p> <pre><code>struct Person {\n  rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n  rfl::Rename&lt;\"lastName\", std::string&gt; last_name = \"Simpson\";\n  std::vector&lt;Person&gt;* children;`\n};\n\nconst auto person =\n  rfl::json::read&lt;Person, rfl::AllowRawPtrs&gt;(json_str);\n</code></pre> <p>However, you must keep in mind that it is now YOUR responsibility to clean up. Otherwise, there WILL be a memory leak.</p> <pre><code>void delete_raw_pointers(const Person&amp; _person) {\n    if (!_person.children) {\n        return;\n    }\n    for (const auto&amp; child: _person.children) {\n        delete_raw_pointers(child);\n    }\n    delete _person.children;\n}\n\ndelete_raw_pointers(person);\n</code></pre> <p><code>std::string_view</code> and <code>std::span</code> must be cleaned up using <code>delete[]</code>, like this:</p> <pre><code>delete[] person.string_view.data();\n\nif(!person.span.empty()) {\n    delete[] person.span.data();\n}\n</code></pre>"},{"location":"concepts/processors/#rfldefaultifmissing","title":"<code>rfl::DefaultIfMissing</code>","text":"<p>The <code>rfl::DefaultIfMissing</code> processor is only relevant for reading data. For writing data, it will make no difference.</p> <p>Usually, when fields are missing in the input data, this will lead to an error  (unless they are optional fields). But if you pass the <code>rfl::DefaultIfMissing</code> processor, then missing fields will be replaced by their default value.</p> <p>For instance, consider the following struct:</p> <pre><code>struct Person {\n  std::string first_name;\n  std::string last_name = \"Simpson\";\n  std::string town;\n};\n</code></pre> <p>Suppose you are reading a JSON like this:</p> <pre><code>{\"first_name\":\"Homer\"}\n</code></pre> <pre><code>rfl::json::read&lt;Person, rfl::DefaultIfMissing&gt;(json_string);\n</code></pre> <p>Then the resulting struct will be equivalent to what you would have gotten had you read the following JSON string:</p> <pre><code>{\"first_name\":\"Homer\",\"last_name\":\"Simpson\",\"town\":\"\"}\n</code></pre> <p><code>last_name</code> and <code>town</code> have been replaced by the default values. Because you have not passed a default value to town, the default value of the type is used instead.</p>"},{"location":"concepts/processors/#rflnoextrafields","title":"<code>rfl::NoExtraFields</code>","text":"<p>When reading an object and the object contains a field that cannot be  matched to any of the fields in the struct, that field is simply ignored.</p> <p>However, when <code>rfl::NoExtraFields</code> is added to <code>read</code>, then such extra fields will lead to an error. </p> <p>This can be overriden by adding <code>rfl::ExtraFields</code> to the struct.</p> <p>Example:</p> <pre><code>struct Person {\n  std::string first_name;\n  std::string last_name = \"Simpson\";\n};\n</code></pre> <pre><code>{\"first_name\":\"Homer\",\"last_name\":\"Simpson\",\"extra_field\":0}\n</code></pre> <p>If you call <code>rfl::json::read&lt;Person&gt;(json_string)</code>, then <code>extra_field</code> will  simply be ignored.</p> <p>But if you call <code>rfl::json::read&lt;Person, rfl::NoExtraFields&gt;(json_string)</code>, you will get an error.</p> <p>However, suppose the struct looked like this:</p> <pre><code>struct Person {\n  std::string first_name;\n  std::string last_name = \"Simpson\";\n  rfl::ExtraFields&lt;int&gt; extras;\n};\n</code></pre> <p>In this case, <code>rfl::json::read&lt;Person, rfl::NoExtraFields&gt;(json_string)</code> will not fail, because <code>extra_field</code> would be included in <code>extras</code>.</p>"},{"location":"concepts/processors/#rflnofieldnames","title":"<code>rfl::NoFieldNames</code>","text":"<p>We can also remove the field names altogether: </p> <pre><code>const auto json_string = \n  rfl::json::write&lt;rfl::NoFieldNames&gt;(homer);\n\nconst auto homer2 = \n  rfl::json::read&lt;Person, rfl::NoFieldNames&gt;(json_string).value();\n</code></pre> <p>The resulting JSON string looks like this:</p> <pre><code>[\"Homer\",\"Simpson\",45]\n</code></pre> <p>This is particularly relevant for binary formats, which do not emphasize readability, like msgpack or flexbuffers. Removing the field names can reduce the size of the resulting bytestrings and significantly speed up read and write time,  depending on the dataset.</p> <p>However, it makes it more difficult to maintain backwards compatability.</p> <p>Note that <code>rfl::NoFieldNames</code> is not supported for BSON, TOML, XML, or YAML, due to limitations of these formats. </p>"},{"location":"concepts/processors/#rflnooptionals","title":"<code>rfl::NoOptionals</code>","text":"<p>As we have seen in the section on optional fields, when a <code>std::optional</code> is <code>std::nullopt</code>, it is usually not written at all. But if you want them to be explicitly written as <code>null</code>, you can use this processor. The same thing applies to <code>std::shared_ptr</code> and  <code>std::unique_ptr</code>.</p> <pre><code>struct Person {\n  std::string first_name;\n  std::string last_name = \"Simpson\";\n  std::optional&lt;std::string&gt; town = std::nullopt;\n};\n\nconst auto homer = Person{.first_name = \"Homer\"};\n\nrfl::json::write&lt;rfl::NoOptionals&gt;(homer);\n</code></pre> <p>The resulting JSON string looks like this:</p> <pre><code>{\"first_name\":\"Homer\",\"last_name\":\"Simpson\",\"town\":null}\n</code></pre> <p>By default, <code>rfl::json::read</code> will accept both <code>\"town\":null</code> and just  leaving out the field <code>town</code>. However, if you want to require the field <code>town</code> to be included, you can add <code>rfl::NoOptionals</code> to <code>read</code>:</p> <pre><code>rfl::json::read&lt;Person, rfl::NoOptionals&gt;(json_string);\n</code></pre>"},{"location":"concepts/processors/#rflunderlyingenums","title":"<code>rfl::UnderlyingEnums</code>","text":"<p>By passing the processor <code>rfl::UnderlyingEnums</code>, fields of the enum type will be written and read as integers</p> <pre><code>enum class Color { red, green, blue, yellow };\n\nstruct Circle {\n  float radius;\n  Color color;\n};\n\nconst auto circle = Circle{.radius = 2.0, .color = Color::green};\n\nrfl::json::write&lt;rfl::UnderlyingEnums&gt;(circle);\n</code></pre> <p>The resulting JSON string looks like this:</p> <pre><code>{\"radius\":2.0,\"color\":1}\n</code></pre>"},{"location":"concepts/processors/#rflsnakecasetocamelcase","title":"<code>rfl::SnakeCaseToCamelCase</code>","text":"<p>Please refer to the example above.</p>"},{"location":"concepts/processors/#rflsnakecasetopascalcase","title":"<code>rfl::SnakeCaseToPascalCase</code>","text":"<p>If you want <code>PascalCase</code> instead of <code>camelCase</code>, you can use the appropriate processor:</p> <pre><code>const auto json_string = \n  rfl::json::write&lt;rfl::SnakeCaseToPascalCase&gt;(homer);\n\nconst auto homer2 = \n  rfl::json::read&lt;Person, rfl::SnakeCaseToPascalCase&gt;(json_string).value();\n</code></pre> <p>The resulting JSON string looks like this:</p> <pre><code>{\"FirstName\":\"Homer\",\"LastName\":\"Simpson\",\"Age\":45}\n</code></pre>"},{"location":"concepts/processors/#combining-several-processors","title":"Combining several processors","text":"<p>You can combine several processors:</p> <pre><code>const auto json_string = \n  rfl::json::write&lt;rfl::SnakeCaseToCamelCase, rfl::AddStructName&lt;\"type\"&gt;&gt;(homer);\n\nconst auto homer2 = \n  rfl::json::read&lt;Person, rfl::SnakeCaseToCamelCase, rfl::AddStructName&lt;\"type\"&gt;&gt;(json_string).value();\n</code></pre> <p>The resulting JSON string looks like this:</p> <pre><code>{\"type\":\"Person\",\"firstName\":\"Homer\",\"lastName\":\"Simpson\",\"age\":45}\n</code></pre> <p>When you have several processors, it is probably more convenient to combine them like this:</p> <pre><code>using Processors = rfl::Processors&lt;\n    rfl::SnakeCaseToCamelCase, rfl::AddStructName&lt;\"type\"&gt;&gt;;\n\nconst auto json_string = rfl::json::write&lt;Processors&gt;(homer);\n\nconst auto homer2 = rfl::json::read&lt;Person, Processors&gt;(json_string).value();\n</code></pre> <p>The resulting JSON string looks like this:</p> <pre><code>{\"type\":\"Person\",\"firstName\":\"Homer\",\"lastName\":\"Simpson\",\"age\":45}\n</code></pre>"},{"location":"concepts/processors/#writing-your-own-processors","title":"Writing your own processors","text":"<p>In principle, writing your own processors is not very difficult. You need to define a struct, which takes has a static method called <code>process</code> taking a named tuple as an input and then returning a modified named tuple. The <code>process</code> method should accept the type of the original struct as a template parameter.</p> <pre><code>struct MyOwnProcessor {\n  template &lt;class StructType&gt;\n  static auto process(auto&amp;&amp; _named_tuple) {...}\n};\n</code></pre>"},{"location":"concepts/structs/","title":"Structs","text":"<p>Structs can be set up as follows:</p> <pre><code>struct Person {\n    std::string first_name;\n    std::string last_name;\n    std::vector&lt;Person&gt; children;\n};\n</code></pre> <p>You can initilize your struct like this:</p> <pre><code>const auto bart = Person{.first_name = \"Bart\",\n                         .last_name = \"Simpson\",\n                         .children = std::vector&lt;Person&gt;()};\n</code></pre> <p>JSON uses camel case, but C++ uses snake case, so you might want to rename your fields:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    std::vector&lt;Person&gt; children;\n};\n</code></pre> <p>You can also initialize fields in the struct declaration itself:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name = \"Simpson\";\n    std::vector&lt;Person&gt; children;\n};\n</code></pre> <p>Because you now have explicitly set this field, you do not have to do this every time:</p> <pre><code>const auto bart = Person{.first_name = \"Bart\"};\n\nconst auto lisa = Person{.first_name = \"Lisa\"};\n\nconst auto maggie = Person{.first_name = \"Maggie\"};\n\nconst auto homer = Person{.first_name = \"Homer\",\n                          .children = std::vector&lt;Person&gt;({bart, lisa, maggie})};\n</code></pre> <p>You can write this to a JSON string:</p> <pre><code>const auto json_string = rfl::json::write(homer);\n</code></pre> <pre><code>{\"firstName\":\"Homer\",\"lastName\":\"Simpson\",\"children\":[{\"firstName\":\"Bart\",\"lastName\":\"Simpson\",\"children\":[]},{\"firstName\":\"Lisa\",\"lastName\":\"Simpson\",\"children\":[]},{\"firstName\":\"Maggie\",\"lastName\":\"Simpson\",\"children\":[]}]}\n</code></pre> <p>And you can parse it back into a struct:</p> <pre><code>const auto homer = rfl::json::read&lt;Person&gt;(json_string).value();\n</code></pre>"},{"location":"concepts/structs/#important-note","title":"Important note","text":"<p>Do not create custom constructors on the structs.</p> <p>reflect-cpp needs to be able to create the structs like this:</p> <pre><code>Person{\"Bart\", \"Simpson\", ...};\n</code></pre> <p>But if you create a custom constructor, then C++ will no longer allow this kind of constructions.</p> <p>If you want to create the struct from one of your classes (the most like reason, you want to create custom constructors in the first place), you might want to check out the section on custom classes or custom parsers.</p>"},{"location":"supported_formats/avro/","title":"Avro","text":"<p>For Avro support, you must also include the header <code>&lt;rfl/avro.hpp&gt;</code> and link to the avro-c library. Furthermore, when compiling reflect-cpp, you need to pass <code>-DREFLECTCPP_AVRO=ON</code> to cmake.</p> <p>Avro is a schemaful binary format. This sets it apart from most other formats supported by reflect-cpp, which are schemaless.</p>"},{"location":"supported_formats/avro/#reading-and-writing","title":"Reading and writing","text":"<p>Suppose you have a struct like this:</p> <pre><code>struct Person {\n    std::string first_name;\n    std::string last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n    std::vector&lt;Person&gt; children;\n};\n</code></pre> <p>A <code>Person</code> struct can be serialized to a bytes vector like this:</p> <pre><code>const auto person = Person{...};\nconst std::vector&lt;char&gt; bytes = rfl::avro::write(person);\n</code></pre> <p>You can parse bytes like this:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::avro::read&lt;Person&gt;(bytes);\n</code></pre>"},{"location":"supported_formats/avro/#the-schema","title":"The schema","text":"<p>However, Avro is a schemaful format, so before you serialize or deserialize, you have to declare a schema. In the two function calls above, this is abstracted away.</p> <p>But if you are repeatedly serializing or deserializing the same struct, it is more efficient to generate the schema explicitly:</p> <pre><code>const auto schema = rfl::avro::to_schema&lt;Person&gt;();\n\nconst auto person = Person{...};\nconst std::vector&lt;char&gt; bytes = rfl::avro::write(person, schema);\n\nconst rfl::Result&lt;Person&gt; result = rfl::avro::read&lt;Person&gt;(bytes, schema);\n</code></pre> <p>Avro schemas are created using a JSON-based schema language. You can retrieve the JSON representation like this:</p> <pre><code>// Both calls are equivalent.\nschema.json_str();\nschema.str();\n</code></pre> <p>In this case, the resulting JSON schema representation looks like this:</p> <pre><code>{\"type\":\"record\",\"name\":\"Person\",\"fields\":[{\"name\":\"first_name\",\"type\":{\"type\":\"string\"}},{\"name\":\"last_name\",\"type\":{\"type\":\"string\"}},{\"name\":\"birthday\",\"type\":{\"type\":\"string\"}},{\"name\":\"children\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"Person\"},\"default\":[]}}]}\n</code></pre>"},{"location":"supported_formats/avro/#loading-and-saving","title":"Loading and saving","text":"<p>You can also load and save to disc using a very similar syntax:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::avro::load&lt;Person&gt;(\"/path/to/file.avro\");\n\nconst auto person = Person{...};\nrfl::avro::save(\"/path/to/file.avro\", person);\n</code></pre>"},{"location":"supported_formats/avro/#reading-from-and-writing-into-streams","title":"Reading from and writing into streams","text":"<p>You can also read from and write into any <code>std::istream</code> and <code>std::ostream</code> respectively.</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::avro::read&lt;Person&gt;(my_istream);\n\nconst auto person = Person{...};\nrfl::avro::write(person, my_ostream);\n</code></pre> <p>Note that <code>std::cout</code> is also an ostream, so this works as well:</p> <pre><code>rfl::avro::write(person, std::cout) &lt;&lt; std::endl;\n</code></pre> <p>(Since Avro is a binary format, the readability of this will be limited, but it might be useful for debugging).</p>"},{"location":"supported_formats/avro/#custom-constructors","title":"Custom constructors","text":"<p>One of the great things about C++ is that it gives you control over when and how you code is compiled.</p> <p>For large and complex systems of structs, it is often a good idea to split up your code into smaller compilation units. You can do so using custom constructors.</p> <p>For the Avro format, these must be a static function on your struct or class called <code>from_avro</code> that take a <code>rfl::avro::Reader::InputVarType</code> as input and return the class or the class wrapped in <code>rfl::Result</code>.</p> <p>In your header file you can write something like this:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n\n    using InputVarType = typename rfl::avro::Reader::InputVarType;\n    static rfl::Result&lt;Person&gt; from_avro(const InputVarType&amp; _obj);\n};\n</code></pre> <p>And in your source file, you implement <code>from_avro</code> as follows:</p> <pre><code>rfl::Result&lt;Person&gt; Person::from_avro(const InputVarType&amp; _obj) {\n    const auto from_nt = [](auto&amp;&amp; _nt) {\n        return rfl::from_named_tuple&lt;Person&gt;(std::move(_nt));\n    };\n    return rfl::avro::read&lt;rfl::named_tuple_t&lt;Person&gt;&gt;(_obj)\n        .transform(from_nt);\n}\n</code></pre> <p>This will force the compiler to only compile the Avro parsing when the source file is compiled.</p>"},{"location":"supported_formats/bson/","title":"BSON","text":"<p>For BSON support, you must also include the header <code>&lt;rfl/bson.hpp&gt;</code> and link to the libbson library. Furthermore, when compiling reflect-cpp, you need to pass <code>-DREFLECTCPP_BSON=ON</code> to cmake. If you are using vcpkg, there should be an appropriate feature that will abstract this away for you.</p> <p>Like the name implies, BSON is a JSON-like binary format. It is most notably used by MongoDB.</p>"},{"location":"supported_formats/bson/#reading-and-writing","title":"Reading and writing","text":"<p>Suppose you have a struct like this:</p> <pre><code>struct Person {\n    std::string first_name;\n    std::string last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n    std::vector&lt;Person&gt; children;\n};\n</code></pre> <p>A <code>person</code> can be serialized like this:</p> <pre><code>const auto person = Person{...};\nconst auto bytes = rfl::bson::write(person);\n</code></pre> <p>You can parse bytes like this:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::bson::read&lt;Person&gt;(bytes);\n</code></pre> <p>You can also parse raw pointers (either <code>const char*</code> or <code>const uint8_t*</code>):</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::bson::read&lt;Person&gt;(ptr, length);\n</code></pre>"},{"location":"supported_formats/bson/#loading-and-saving","title":"Loading and saving","text":"<p>You can also load and save to disc using a very similar syntax:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::bson::load&lt;Person&gt;(\"/path/to/file.bson\");\n\nconst auto person = Person{...};\nrfl::bson::save(\"/path/to/file.bson\", person);\n</code></pre>"},{"location":"supported_formats/bson/#reading-from-and-writing-into-streams","title":"Reading from and writing into streams","text":"<p>You can also read from and write into any <code>std::istream</code> and <code>std::ostream</code> respectively.</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::bson::read&lt;Person&gt;(my_istream);\n\nconst auto person = Person{...};\nrfl::bson::write(person, my_ostream);\n</code></pre> <p>Note that <code>std::cout</code> is also an ostream, so this works as well:</p> <pre><code>rfl::bson::write(person, std::cout) &lt;&lt; std::endl;\n</code></pre> <p>(Since BSON is a binary format, the readability of this will be limited, but it might be useful for debugging).</p>"},{"location":"supported_formats/bson/#custom-constructors","title":"Custom constructors","text":"<p>One of the great things about C++ is that it gives you control over when and how you code is compiled.</p> <p>For large and complex systems of structs, it is often a good idea to split up your code into smaller compilation units. You can do so using custom constructors.</p> <p>For the BSON format, these must be a static function on your struct or class called <code>from_bson</code> that take a <code>rfl::bson::Reader::InputVarType</code> as input and return the class or the class wrapped in <code>rfl::Result</code>.</p> <p>In your header file you can write something like this:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n\n    using InputVarType = typename rfl::bson::Reader::InputVarType;\n    static rfl::Result&lt;Person&gt; from_bson(const InputVarType&amp; _obj);\n};\n</code></pre> <p>And in your source file, you implement <code>from_bson</code> as follows:</p> <pre><code>rfl::Result&lt;Person&gt; Person::from_bson(const InputVarType&amp; _obj) {\n    const auto from_nt = [](auto&amp;&amp; _nt) {\n        return rfl::from_named_tuple&lt;Person&gt;(std::move(_nt));\n    };\n    return rfl::bson::read&lt;rfl::named_tuple_t&lt;Person&gt;&gt;(_obj)\n        .transform(from_nt);\n}\n</code></pre> <p>This will force the compiler to only compile the BSON parsing when the source file is compiled.</p>"},{"location":"supported_formats/capnproto/","title":"Cap'n Proto","text":"<p>For Cap'n Proto support, you must also include the header <code>&lt;rfl/capnproto.hpp&gt;</code> and link to the capnproto library. Furthermore, when compiling reflect-cpp, you need to pass <code>-DREFLECTCPP_CAPNPROTO=ON</code> to cmake. If you are using vcpkg or Conan, there should be an appropriate feature (vcpkg) or option (Conan) that will abstract this away for you.</p> <p>Cap'n Proto is a schemaful binary format. This sets it apart from most other formats supported by reflect-cpp, which are schemaless.</p>"},{"location":"supported_formats/capnproto/#reading-and-writing","title":"Reading and writing","text":"<p>Suppose you have a struct like this:</p> <pre><code>struct Person {\n    std::string first_name;\n    std::string last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n    std::vector&lt;Person&gt; children;\n};\n</code></pre> <p>A <code>Person</code> struct can be serialized to a bytes vector like this:</p> <pre><code>const auto person = Person{...};\nconst std::vector&lt;char&gt; bytes = rfl::capnproto::write(person);\n</code></pre> <p>You can parse bytes like this:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::capnproto::read&lt;Person&gt;(bytes);\n</code></pre>"},{"location":"supported_formats/capnproto/#the-schema","title":"The schema","text":"<p>However, Cap'n Proto is a schemaful format, so before you serialize or deserialize, you have to declare a schema. In the two function calls above, this is abstracted away.</p> <p>If you want to, you can pass the schema explicitly, but it will not yield any performance gains, because the schemata are always created upfront:</p> <pre><code>const auto schema = rfl::capnproto::to_schema&lt;Person&gt;();\n\nconst auto person = Person{...};\nconst std::vector&lt;char&gt; bytes = rfl::capnproto::write(person, schema);\n\nconst rfl::Result&lt;Person&gt; result = rfl::capnproto::read&lt;Person&gt;(bytes, schema);\n</code></pre> <p>Cap'n Proto schemas are created using a schema language. You can retrieve the schema like this:</p> <pre><code>schema.str();\n</code></pre> <p>In this case, the resulting schema representation looks like this:</p> <pre><code>@0xdbb9ad1f14bf0b36;\n\nstruct Person {\n  firstName @0 :Text;\n  lastName @1 :Text;\n  birthday @2 :Text;\n  children @3 :List(Person);\n}\n</code></pre>"},{"location":"supported_formats/capnproto/#loading-and-saving","title":"Loading and saving","text":"<p>You can also load and save to disc using a very similar syntax:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::capnproto::load&lt;Person&gt;(\"/path/to/file.capnproto\");\n\nconst auto person = Person{...};\nrfl::capnproto::save(\"/path/to/file.capnproto\", person);\n</code></pre>"},{"location":"supported_formats/capnproto/#reading-from-and-writing-into-streams","title":"Reading from and writing into streams","text":"<p>You can also read from and write into any <code>std::istream</code> and <code>std::ostream</code> respectively.</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::capnproto::read&lt;Person&gt;(my_istream);\n\nconst auto person = Person{...};\nrfl::capnproto::write(person, my_ostream);\n</code></pre> <p>Note that <code>std::cout</code> is also an ostream, so this works as well:</p> <pre><code>rfl::capnproto::write(person, std::cout) &lt;&lt; std::endl;\n</code></pre> <p>(Since Cap'n Proto is a binary format, the readability of this will be limited, but it might be useful for debugging).</p>"},{"location":"supported_formats/capnproto/#custom-constructors","title":"Custom constructors","text":"<p>One of the great things about C++ is that it gives you control over when and how you code is compiled.</p> <p>For large and complex systems of structs, it is often a good idea to split up your code into smaller compilation units. You can do so using custom constructors.</p> <p>For the Cap'n Proto format, these must be a static function on your struct or class called <code>from_capnproto</code> that take a <code>rfl::capnproto::Reader::InputVarType</code> as input and return the class or the class wrapped in <code>rfl::Result</code>.</p> <p>In your header file you can write something like this:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n\n    using InputVarType = typename rfl::capnproto::Reader::InputVarType;\n    static rfl::Result&lt;Person&gt; from_capnproto(const InputVarType&amp; _obj);\n};\n</code></pre> <p>And in your source file, you implement <code>from_capnproto</code> as follows:</p> <pre><code>rfl::Result&lt;Person&gt; Person::from_capnproto(const InputVarType&amp; _obj) {\n    const auto from_nt = [](auto&amp;&amp; _nt) {\n        return rfl::from_named_tuple&lt;Person&gt;(std::move(_nt));\n    };\n    return rfl::capnproto::read&lt;rfl::named_tuple_t&lt;Person&gt;&gt;(_obj)\n        .transform(from_nt);\n}\n</code></pre> <p>This will force the compiler to only compile the Cap'n Proto parsing when the source file is compiled.</p>"},{"location":"supported_formats/cbor/","title":"CBOR","text":"<p>For CBOR support, you must also include the header <code>&lt;rfl/cbor.hpp&gt;</code> and include the jsoncons library.  Note that it is header-only. Furthermore, when compiling reflect-cpp, you need to pass <code>-DREFLECTCPP_CBOR=ON</code> to cmake. If you are using vcpkg or Conan, there should be an appropriate feature (vcpkg) or option (Conan) that will abstract this away for you.</p> <p>CBOR or Concise Binary Object Representation, is a JSON-like binary format with an emphasis on small binary sizes.</p>"},{"location":"supported_formats/cbor/#reading-and-writing","title":"Reading and writing","text":"<p>Suppose you have a struct like this:</p> <pre><code>struct Person {\n    std::string first_name;\n    std::string last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n    std::vector&lt;Person&gt; children;\n};\n</code></pre> <p>A <code>Person</code> can be serialized to a bytes vector like this:</p> <pre><code>const auto person = Person{...};\nconst std::vector&lt;char&gt; bytes = rfl::cbor::write(person);\n</code></pre> <p>You can parse bytes like this:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::cbor::read&lt;Person&gt;(bytes);\n</code></pre>"},{"location":"supported_formats/cbor/#loading-and-saving","title":"Loading and saving","text":"<p>You can also load and save to disc using a very similar syntax:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::cbor::load&lt;Person&gt;(\"/path/to/file.cbor\");\n\nconst auto person = Person{...};\nrfl::cbor::save(\"/path/to/file.cbor\", person);\n</code></pre>"},{"location":"supported_formats/cbor/#reading-from-and-writing-into-streams","title":"Reading from and writing into streams","text":"<p>You can also read from and write into any <code>std::istream</code> and <code>std::ostream</code> respectively.</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::cbor::read&lt;Person&gt;(my_istream);\n\nconst auto person = Person{...};\nrfl::cbor::write(person, my_ostream);\n</code></pre> <p>Note that <code>std::cout</code> is also an ostream, so this works as well:</p> <pre><code>rfl::cbor::write(person, std::cout) &lt;&lt; std::endl;\n</code></pre> <p>(Since CBOR is a binary format, the readability of this will be limited, but it might be useful for debugging).</p>"},{"location":"supported_formats/cbor/#custom-constructors","title":"Custom constructors","text":"<p>One of the great things about C++ is that it gives you control over when and how you code is compiled.</p> <p>For large and complex systems of structs, it is often a good idea to split up your code into smaller compilation units. You can do so using custom constructors.</p> <p>For the CBOR format, these must be a static function on your struct or class called <code>from_cbor</code> that take a <code>rfl::cbor::Reader::InputVarType</code> as input and return the class or the class wrapped in <code>rfl::Result</code>.</p> <p>In your header file you can write something like this:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n\n    using InputVarType = typename rfl::cbor::Reader::InputVarType;\n    static rfl::Result&lt;Person&gt; from_cbor(const InputVarType&amp; _obj);\n};\n</code></pre> <p>And in your source file, you implement <code>from_cbor</code> as follows:</p> <pre><code>rfl::Result&lt;Person&gt; Person::from_cbor(const InputVarType&amp; _obj) {\n    const auto from_nt = [](auto&amp;&amp; _nt) {\n        return rfl::from_named_tuple&lt;Person&gt;(std::move(_nt));\n    };\n    return rfl::cbor::read&lt;rfl::named_tuple_t&lt;Person&gt;&gt;(_obj)\n        .transform(from_nt);\n}\n</code></pre> <p>This will force the compiler to only compile the CBOR parsing when the source file is compiled.</p>"},{"location":"supported_formats/csv/","title":"csv","text":"<p>For CSV support, include the header <code>&lt;rfl/csv.hpp&gt;</code> and link to the Apache Arrow library. Furthermore, when compiling reflect-cpp, you need to pass <code>-DREFLECTCPP_CSV=ON</code> to cmake.</p> <p>CSV is a tabular text format. Like other tabular formats in reflect-cpp, CSV is designed for collections of flat records and has limitations for nested or variant types.</p>"},{"location":"supported_formats/csv/#reading-and-writing","title":"Reading and writing","text":"<p>Suppose you have a struct like this:</p> <pre><code>struct Person {\n    std::string first_name;\n    std::string last_name = \"Simpson\";\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n    unsigned int age;\n    rfl::Email email;\n};\n</code></pre> <p>Important: CSV is a tabular format that requires collections of records. You cannot serialize individual structs - you must use containers like <code>std::vector&lt;Person&gt;</code>, <code>std::deque&lt;Person&gt;</code>, etc.</p> <p>Write a collection to a string (CSV bytes) like this:</p> <pre><code>const auto people = std::vector&lt;Person&gt;{\n    Person{.first_name = \"Bart\", .birthday = \"1987-04-19\", .age = 10, .email = \"bart@simpson.com\"},\n    Person{.first_name = \"Lisa\", .birthday = \"1987-04-19\", .age = 8, .email = \"lisa@simpson.com\"}\n};\n\nconst std::string csv_text = rfl::csv::write(people);\n</code></pre> <p>Parse from a string or bytes view:</p> <pre><code>const rfl::Result&lt;std::vector&lt;Person&gt;&gt; result = rfl::csv::read&lt;std::vector&lt;Person&gt;&gt;(csv_text);\n</code></pre>"},{"location":"supported_formats/csv/#settings","title":"Settings","text":"<p>CSV behavior can be configured using <code>rfl::csv::Settings</code>:</p> <pre><code>const auto settings = rfl::csv::Settings{}\n    .with_delimiter(';')\n    .with_quoting(true)\n    .with_quote_char('\"')\n    .with_null_string(\"n/a\")\n    .with_double_quote(true)\n    .with_escaping(false)\n    .with_escape_char('\\\\')\n    .with_newlines_in_values(false)\n    .with_ignore_empty_lines(true)\n    .with_batch_size(1024);\n\nconst std::string csv_text = rfl::csv::write(people, settings);\n</code></pre> <p>Key options: - <code>batch_size</code> - Maximum number of rows processed per batch (performance tuning) - <code>delimiter</code> - Field delimiter character - <code>quoting</code> - Whether to use quoting when writing - <code>quote_char</code> - Quote character used when reading - <code>null_string</code> - String representation for null values - <code>double_quote</code> - Whether a quote inside a value is double-quoted (reading) - <code>escaping</code> - Whether escaping is used (reading) - <code>escape_char</code> - Escape character (reading) - <code>newlines_in_values</code> - Whether CR/LF are allowed inside values (reading) - <code>ignore_empty_lines</code> - Whether empty lines are ignored (reading)</p>"},{"location":"supported_formats/csv/#loading-and-saving","title":"Loading and saving","text":"<p>You can load from and save to disk:</p> <pre><code>const rfl::Result&lt;std::vector&lt;Person&gt;&gt; result = rfl::csv::load&lt;std::vector&lt;Person&gt;&gt;(\"/path/to/file.csv\");\n\nconst auto people = std::vector&lt;Person&gt;{...};\nrfl::csv::save(\"/path/to/file.csv\", people);\n</code></pre> <p>With custom settings:</p> <pre><code>const auto settings = rfl::csv::Settings{}.with_delimiter(';');\nrfl::csv::save(\"/path/to/file.csv\", people, settings);\n</code></pre>"},{"location":"supported_formats/csv/#reading-from-and-writing-into-streams","title":"Reading from and writing into streams","text":"<p>You can read from any <code>std::istream</code> and write to any <code>std::ostream</code>:</p> <pre><code>const rfl::Result&lt;std::vector&lt;Person&gt;&gt; result = rfl::csv::read&lt;std::vector&lt;Person&gt;&gt;(my_istream);\n\nconst auto people = std::vector&lt;Person&gt;{...};\nrfl::csv::write(people, my_ostream);\n</code></pre> <p>With custom settings:</p> <pre><code>const auto settings = rfl::csv::Settings{}.with_delimiter(';');\nrfl::csv::write(people, my_ostream, settings);\n</code></pre>"},{"location":"supported_formats/csv/#field-name-transformations","title":"Field name transformations","text":"<p>Like other formats, CSV supports field name transformations via processors, e.g. <code>SnakeCaseToCamelCase</code>:</p> <pre><code>const auto people = std::vector&lt;Person&gt;{...};\nconst auto result = rfl::csv::read&lt;std::vector&lt;Person&gt;, rfl::SnakeCaseToCamelCase&gt;(csv_text);\n</code></pre>"},{"location":"supported_formats/csv/#enums-and-validation","title":"Enums and validation","text":"<p>CSV supports enums and validated types. Enums are written/read as strings:</p> <pre><code>enum class FirstName { Bart, Lisa, Maggie, Homer };\n\nstruct Person {\n    rfl::Rename&lt;\"firstName\", FirstName&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n    rfl::Validator&lt;unsigned int, rfl::Minimum&lt;0&gt;, rfl::Maximum&lt;130&gt;&gt; age;\n    rfl::Email email;\n};\n</code></pre>"},{"location":"supported_formats/csv/#limitations-of-tabular-formats","title":"Limitations of tabular formats","text":"<p>CSV, like other tabular formats, has limitations compared to hierarchical formats such as JSON or XML:</p>"},{"location":"supported_formats/csv/#collections-requirement","title":"Collections requirement","text":"<p>You must serialize collections, not individual objects: <pre><code>std::vector&lt;Person&gt; people = {...};  // \u2705 Correct\nPerson person = {...};               // \u274c Wrong - must be in a container\n</code></pre></p>"},{"location":"supported_formats/csv/#no-nested-objects","title":"No nested objects","text":"<p>Each field must be a primitive type, enum, or a simple validated type. Nested objects are not automatically flattened: <pre><code>// This would NOT work as expected - nested objects are not automatically flattened\nstruct Address {\n    std::string street;\n    std::string city;\n};\n\nstruct Person {\n    std::string first_name;\n    std::string last_name;\n    Address address;  // \u274c Will cause compilation errors for CSV\n};\n</code></pre></p>"},{"location":"supported_formats/csv/#using-rflflatten-for-nested-objects","title":"Using rfl::Flatten for nested objects","text":"<p>If you need to include nested objects, use <code>rfl::Flatten</code> to explicitly flatten them: <pre><code>struct Address {\n    std::string street;\n    std::string city;\n};\n\nstruct Person {\n    std::string first_name;\n    std::string last_name;\n    rfl::Flatten&lt;Address&gt; address;  // \u2705 This will flatten the Address fields\n};\n\n// The resulting CSV will have columns: first_name, last_name, street, city\n</code></pre></p>"},{"location":"supported_formats/csv/#no-variant-types","title":"No variant types","text":"<p>Variant types like <code>std::variant</code>, <code>rfl::Variant</code>, or <code>rfl::TaggedUnion</code> cannot be serialized to CSV as separate columns: <pre><code>// \u274c This will NOT work\nstruct Person {\n    std::string first_name;\n    std::variant&lt;std::string, int&gt; status;  // Variant - not supported\n    rfl::Variant&lt;std::string, int&gt; type;    // rfl::Variant - not supported\n    rfl::TaggedUnion&lt;\"type\", std::string, int&gt; category;  // TaggedUnion - not supported\n};\n</code></pre></p>"},{"location":"supported_formats/csv/#no-arrays-except-bytestrings","title":"No arrays (except bytestrings)","text":"<p>CSV output here does not support arrays (lists) of values in a single column. The only array-like field supported is binary data represented as bytestrings: <pre><code>// \u274c This will NOT work\nstruct Person {\n    std::string first_name;\n    std::vector&lt;std::string&gt; hobbies;  // Array of strings - not supported\n    std::vector&lt;int&gt; scores;           // Array of integers - not supported\n    std::vector&lt;Address&gt; addresses;    // Array of objects - not supported\n};\n\n// \u2705 This works\nstruct Blob {\n    std::vector&lt;char&gt; binary_data;      // Binary data supported as bytestring\n};\n</code></pre></p>"},{"location":"supported_formats/csv/#use-cases","title":"Use cases","text":"<p>CSV is ideal for: - Data exchange and interoperability - Simple, flat data structures with consistent types - Human-readable datasets</p> <p>CSV is less suitable for: - Complex nested data structures - Data with arrays or variant types - Strict schemas with evolving types - Very large datasets where binary columnar formats are preferred</p>"},{"location":"supported_formats/flexbuffers/","title":"Flexbuffers","text":"<p>For flexbuffers support, you must also include the header <code>&lt;rfl/flexbuf.hpp&gt;</code> and link to the flatbuffers library. Furthermore, when compiling reflect-cpp, you need to pass <code>-DREFLECTCPP_FLEXBUFFERS=ON</code> to cmake. If you are using vcpkg or Conan, there should be an appropriate feature (vcpkg) or option (Conan) that will abstract this away for you.</p> <p>Flexbuffers is part of the flatbuffers library, which is a binary format developed by Google.</p> <p>reflect-cpp can be used on top of flexbuffers. To see how this is advantageous, consider the following example:</p>"},{"location":"supported_formats/flexbuffers/#simple-example","title":"Simple example","text":"<pre><code>#include &lt;rfl.hpp&gt;\n#include &lt;rfl/flexbuf.hpp&gt;\n\nusing Color = rfl::Literal&lt;\"Red\", \"Green\", \"Blue\"&gt;;\n\nstruct Weapon {\n  std::string name;\n  short damage;\n};\n\nusing Equipment = rfl::Variant&lt;rfl::Field&lt;\"weapon\", Weapon&gt;&gt;;\n\nstruct Vec3 {\n  float x;\n  float y;\n  float z;\n};\n\nstruct Monster {\n  Vec3 pos;\n  short mana = 150;\n  short hp = 100;\n  std::string name;\n  bool friendly = false;\n  std::vector&lt;std::uint8_t&gt; inventory;\n  Color color = Color::make&lt;\"Blue\"&gt;();\n  std::vector&lt;Weapon&gt; weapons;\n  Equipment equipped;\n  std::vector&lt;Vec3&gt; path;\n};\n\nconst auto sword = Weapon{.name = \"Sword\", .damage = 3};\nconst auto axe = Weapon{.name = \"Axe\", .damage = 5};\n\nconst auto weapons = std::vector&lt;Weapon&gt;({sword, axe});\n\nconst auto position = Vec3{1.0f, 2.0f, 3.0f};\n\nconst auto inventory =\n    std::vector&lt;std::uint8_t&gt;({0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n\nconst auto orc = Monster{.pos = position,\n                         .mana = 150,\n                         .hp = 80,\n                         .name = \"MyMonster\",\n                         .inventory = inventory,\n                         .color = Color::make&lt;\"Red\"&gt;(),\n                         .weapons = weapons,\n                         .equipped = rfl::make_field&lt;\"weapon\"&gt;(axe)};\n\nconst auto bytes = rfl::flexbuf::write(orc);\n\nconst auto res = rfl::flexbuf::read&lt;Monster&gt;(bytes);\n</code></pre>"},{"location":"supported_formats/flexbuffers/#for-comparison-standard-flatbuffers","title":"For comparison: Standard flatbuffers","text":"<p>Let's talk about what normal flatbuffers would make you do to set up this example.</p> <p>First of all, you would have to set up your <code>Monster.fbs</code>:</p> <pre><code>namespace MyGame.Sample;\n\nenum Color:byte { Red = 0, Green, Blue = 2 }\n\nunion Equipment { Weapon } // Optionally add more tables.\n\nstruct Vec3 {\n  x:float;\n  y:float;\n  z:float;\n}\n\ntable Monster {\n  pos:Vec3;\n  mana:short = 150;\n  hp:short = 100;\n  name:string;\n  friendly:bool = false (deprecated);\n  inventory:[ubyte];\n  color:Color = Blue;\n  weapons:[Weapon];\n  equipped:Equipment;\n  path:[Vec3];\n}\n\ntable Weapon {\n  name:string;\n  damage:short;\n}\n\nroot_type Monster;\n</code></pre> <p>Then you would have to generate the C++ code using the flatbuffers compiler.</p> <p>Finally, here is the code that you would then write afterwards:</p> <pre><code>// Build up a serialized buffer algorithmically:\nflatbuffers::FlatBufferBuilder builder;\n\n// First, lets serialize some weapons for the Monster: A 'sword' and an 'axe'.\nauto weapon_one_name = builder.CreateString(\"Sword\");\nshort weapon_one_damage = 3;\n\nauto weapon_two_name = builder.CreateString(\"Axe\");\nshort weapon_two_damage = 5;\n\n// Use the `CreateWeapon` shortcut to create Weapons with all fields set.\nauto sword = CreateWeapon(builder, weapon_one_name, weapon_one_damage);\nauto axe = CreateWeapon(builder, weapon_two_name, weapon_two_damage);\n\n// Create a FlatBuffer's `vector` from the `std::vector`.\nstd::vector&lt;flatbuffers::Offset&lt;Weapon&gt;&gt; weapons_vector;\nweapons_vector.push_back(sword);\nweapons_vector.push_back(axe);\nauto weapons = builder.CreateVector(weapons_vector);\n\n// Second, serialize the rest of the objects needed by the Monster.\nauto position = Vec3(1.0f, 2.0f, 3.0f);\n\nauto name = builder.CreateString(\"MyMonster\");\n\nunsigned char inv_data[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\nauto inventory = builder.CreateVector(inv_data, 10);\n\n// Shortcut for creating monster with all fields set:\nauto orc = CreateMonster(builder, &amp;position, 150, 80, name, inventory,\n                         Color_Red, weapons, Equipment_Weapon, axe.Union());\n\nbuilder.Finish(orc);  // Serialize the root of the object.\n</code></pre> <p>I think it should be fairly obvious that using reflect-cpp on top drastically reduces the amount of boilerplate code.</p> <p>But what it more, unlike \"normal\" flatbuffers, flexbuffers also supports field names. Field names make it a lot easier to maintain backwards compatability.</p>"},{"location":"supported_formats/flexbuffers/#reading-and-writing","title":"Reading and writing","text":"<p>Suppose you have a struct like this:</p> <pre><code>struct Person {\n    std::string first_name;\n    std::string last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n    std::vector&lt;Person&gt; children;\n};\n</code></pre> <p>A <code>person</code> can be turned into a bytes vector like this:</p> <pre><code>const auto person = Person{...};\nconst auto bytes = rfl::flexbuf::write(person);\n</code></pre> <p>You can parse bytes like this:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::flexbuf::read&lt;Person&gt;(bytes);\n</code></pre>"},{"location":"supported_formats/flexbuffers/#loading-and-saving","title":"Loading and saving","text":"<p>You can also load and save to disc using a very similar syntax:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::flexbuf::load&lt;Person&gt;(\"/path/to/file.fb\");\n\nconst auto person = Person{...};\nrfl::flexbuf::save(\"/path/to/file.fb\", person);\n</code></pre>"},{"location":"supported_formats/flexbuffers/#reading-from-and-writing-into-streams","title":"Reading from and writing into streams","text":"<p>You can also read from and write into any <code>std::istream</code> and <code>std::ostream</code> respectively.</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::flexbuf::read&lt;Person&gt;(my_istream);\n\nconst auto person = Person{...};\nrfl::flexbuf::write(person, my_ostream);\n</code></pre> <p>Note that <code>std::cout</code> is also an ostream, so this works as well:</p> <pre><code>rfl::flexbuf::write(person, std::cout) &lt;&lt; std::endl;\n</code></pre> <p>(Since flexbuffers is a binary format, the readability of this will be limited, but it might be useful for debugging).</p>"},{"location":"supported_formats/flexbuffers/#custom-constructors","title":"Custom constructors","text":"<p>One of the great things about C++ is that it gives you control over when and how you code is compiled.</p> <p>For large and complex systems of structs, it is often a good idea to split up your code into smaller compilation units. You can do so using custom constructors.</p> <p>For the flexbuffers format, these must be a static function on your struct or class called <code>from_flexbuf</code> that take a <code>rfl::flexbuf::Reader::InputVarType</code> as input and return the class or the class wrapped in <code>rfl::Result</code>.</p> <p>In your header file you can write something like this:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n\n    using InputVarType = typename rfl::flexbuf::Reader::InputVarType;\n    static rfl::Result&lt;Person&gt; from_flexbuf(const InputVarType&amp; _obj);\n};\n</code></pre> <p>And in your source file, you implement <code>from_flexbuf</code> as follows:</p> <pre><code>rfl::Result&lt;Person&gt; Person::from_flexbuf(const InputVarType&amp; _obj) {\n    const auto from_nt = [](auto&amp;&amp; _nt) {\n        return rfl::from_named_tuple&lt;Person&gt;(std::move(_nt));\n    };\n    return rfl::flexbuf::read&lt;rfl::named_tuple_t&lt;Person&gt;&gt;(_obj)\n        .transform(from_nt);\n}\n</code></pre> <p>This will force the compiler to only compile the flexbuffers parsing when the source file is compiled.</p>"},{"location":"supported_formats/json/","title":"JSON","text":"<p>For JSON support, you must also include the header <code>&lt;rfl/json.hpp&gt;</code>.</p>"},{"location":"supported_formats/json/#reading-and-writing","title":"Reading and writing","text":"<p>Suppose you have a struct like this:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n    std::vector&lt;Person&gt; children;\n};\n</code></pre> <p>You can parse JSON strings like this:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::json::read&lt;Person&gt;(json_string);\n</code></pre> <p>A <code>Person</code> struct can be serialized like this:</p> <pre><code>const auto person = Person{...};\nconst std::string json_string = rfl::json::write(person);\n</code></pre> <p>If you want a \"pretty\" JSON representation, you can do this:</p> <pre><code>const std::string json_string = rfl::json::write(person, rfl::json::pretty);\n</code></pre>"},{"location":"supported_formats/json/#loading-and-saving","title":"Loading and saving","text":"<p>You can also load and save to disc using a very similar syntax:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::json::load&lt;Person&gt;(\"/path/to/file.json\");\n\nconst auto person = Person{...};\nrfl::json::save(\"/path/to/file.json\", person);\n</code></pre> <p><code>rfl::json::pretty</code> will work here as well:</p> <pre><code>rfl::json::save(\"/path/to/file.json\", person, rfl::json::pretty);\n</code></pre>"},{"location":"supported_formats/json/#reading-from-and-writing-into-streams","title":"Reading from and writing into streams","text":"<p>You can also read from and write into any <code>std::istream</code> and <code>std::ostream</code> respectively.</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::json::read&lt;Person&gt;(my_istream);\n\nconst auto person = Person{...};\nrfl::json::write(person, my_ostream);\n</code></pre> <p><code>rfl::json::pretty</code> will work here as well:</p> <pre><code>rfl::json::write(person, my_ostream, rfl::json::pretty);\n</code></pre> <p>Note that <code>std::cout</code> is also an ostream, so this works as well:</p> <pre><code>rfl::json::write(person, std::cout) &lt;&lt; std::endl;\n</code></pre>"},{"location":"supported_formats/json/#custom-constructors","title":"Custom constructors","text":"<p>One of the great things about C++ is that it gives you control over when and how you code is compiled.</p> <p>For large and complex systems of structs, it is often a good idea to split up your code into smaller compilation units. You can do so using custom constructors.</p> <p>For the JSON format, these must be a static function on your struct or class called <code>from_json_obj</code> that take a <code>rfl::json::Reader::InputVarType</code> as input and return the class or the class wrapped in <code>rfl::Result</code>.</p> <p>In your header file you can write something like this:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n\n    using JSONVar = typename rfl::json::Reader::InputVarType;\n    static rfl::Result&lt;Person&gt; from_json_obj(const JSONVar&amp; _obj);\n};\n</code></pre> <p>And in your source file, you implement <code>from_json_obj</code> as follows:</p> <pre><code>rfl::Result&lt;Person&gt; Person::from_json_obj(const JSONVar&amp; _obj) {\n    const auto from_nt = [](auto&amp;&amp; _nt) {\n        return rfl::from_named_tuple&lt;Person&gt;(std::move(_nt));\n    };\n    return rfl::json::read&lt;rfl::named_tuple_t&lt;Person&gt;&gt;(_obj)\n        .transform(from_nt);\n}\n</code></pre> <p>This will force the compiler to only compile the JSON parsing when the source file is compiled.</p>"},{"location":"supported_formats/msgpack/","title":"msgpack","text":"<p>For msgpack support, you must also include the header <code>&lt;rfl/msgpack.hpp&gt;</code> and link to the msgpack-c library. Furthermore, when compiling reflect-cpp, you need to pass <code>-DREFLECTCPP_MSGPACK=ON</code> to cmake. If you are using vcpkg or Conan, there should be an appropriate feature (vcpkg) or option (Conan) that will abstract this away for you.</p> <p>msgpack is a JSON-like binary format with an emphasis on small binary sizes.</p>"},{"location":"supported_formats/msgpack/#reading-and-writing","title":"Reading and writing","text":"<p>Suppose you have a struct like this:</p> <pre><code>struct Person {\n    std::string first_name;\n    std::string last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n    std::vector&lt;Person&gt; children;\n};\n</code></pre> <p>A <code>Person</code> can be serialized like this:</p> <pre><code>const auto person = Person{...};\nconst std::vector&lt;char&gt; bytes = rfl::msgpack::write(person);\n</code></pre> <p>You can parse bytes like this:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::msgpack::read&lt;Person&gt;(bytes);\n</code></pre>"},{"location":"supported_formats/msgpack/#loading-and-saving","title":"Loading and saving","text":"<p>You can also load and save to disc using a very similar syntax:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::msgpack::load&lt;Person&gt;(\"/path/to/file.msgpack\");\n\nconst auto person = Person{...};\nrfl::msgpack::save(\"/path/to/file.msgpack\", person);\n</code></pre>"},{"location":"supported_formats/msgpack/#reading-from-and-writing-into-streams","title":"Reading from and writing into streams","text":"<p>You can also read from and write into any <code>std::istream</code> and <code>std::ostream</code> respectively.</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::msgpack::read&lt;Person&gt;(my_istream);\n\nconst auto person = Person{...};\nrfl::msgpack::write(person, my_ostream);\n</code></pre> <p>Note that <code>std::cout</code> is also an ostream, so this works as well:</p> <pre><code>rfl::msgpack::write(person, std::cout) &lt;&lt; std::endl;\n</code></pre> <p>(Since msgpack is a binary format, the readability of this will be limited, but it might be useful for debugging).</p>"},{"location":"supported_formats/msgpack/#custom-constructors","title":"Custom constructors","text":"<p>One of the great things about C++ is that it gives you control over when and how you code is compiled.</p> <p>For large and complex systems of structs, it is often a good idea to split up your code into smaller compilation units. You can do so using custom constructors.</p> <p>For the msgpack format, these must be a static function on your struct or class called <code>from_msgpack</code> that take a <code>rfl::msgpack::Reader::InputVarType</code> as input and return the class or the class wrapped in <code>rfl::Result</code>.</p> <p>In your header file you can write something like this:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n\n    using InputVarType = typename rfl::msgpack::Reader::InputVarType;\n    static rfl::Result&lt;Person&gt; from_msgpack(const InputVarType&amp; _obj);\n};\n</code></pre> <p>And in your source file, you implement <code>from_msgpack</code> as follows:</p> <pre><code>rfl::Result&lt;Person&gt; Person::from_msgpack(const InputVarType&amp; _obj) {\n    const auto from_nt = [](auto&amp;&amp; _nt) {\n        return rfl::from_named_tuple&lt;Person&gt;(std::move(_nt));\n    };\n    return rfl::msgpack::read&lt;rfl::named_tuple_t&lt;Person&gt;&gt;(_obj)\n        .transform(from_nt);\n}\n</code></pre> <p>This will force the compiler to only compile the msgpack parsing when the source file is compiled.</p>"},{"location":"supported_formats/parquet/","title":"parquet","text":"<p>For Parquet support, you must also include the header <code>&lt;rfl/parquet.hpp&gt;</code> and link to the Apache Arrow and Apache Parquet libraries. Furthermore, when compiling reflect-cpp, you need to pass <code>-DREFLECTCPP_PARQUET=ON</code> to cmake.</p> <p>Parquet is a columnar storage format optimized for analytical workloads. Unlike most other formats supported by reflect-cpp, Parquet is designed for tabular data and has specific limitations regarding nested structures.</p>"},{"location":"supported_formats/parquet/#reading-and-writing","title":"Reading and writing","text":"<p>Suppose you have a struct like this:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n    unsigned int age;\n    rfl::Email email;\n};\n</code></pre> <p>Important: Parquet is a tabular format that requires collections of records. You cannot serialize individual structs - you must use containers like <code>std::vector&lt;Person&gt;</code>, <code>std::deque&lt;Person&gt;</code>, etc.</p> <p>A collection of <code>Person</code> structs can be serialized to a bytes vector like this:</p> <pre><code>const auto people = std::vector&lt;Person&gt;{\n    Person{.first_name = \"Bart\", .birthday = \"1987-04-19\", .age = 10, .email = \"bart@simpson.com\"},\n    Person{.first_name = \"Lisa\", .birthday = \"1987-04-19\", .age = 8, .email = \"lisa@simpson.com\"}\n};\nconst std::vector&lt;char&gt; bytes = rfl::parquet::write(people);\n</code></pre> <p>You can parse bytes like this:</p> <pre><code>const rfl::Result&lt;std::vector&lt;Person&gt;&gt; result = rfl::parquet::read&lt;std::vector&lt;Person&gt;&gt;(bytes);\n</code></pre>"},{"location":"supported_formats/parquet/#settings-and-compression","title":"Settings and compression","text":"<p>Parquet supports various compression algorithms and chunk sizes. You can configure these using the <code>Settings</code> struct:</p> <pre><code>const auto settings = rfl::parquet::Settings{}\n    .with_compression(rfl::parquet::Compression::GZIP)\n    .with_chunksize(1000);\n\nconst std::vector&lt;char&gt; bytes = rfl::parquet::write(people, settings);\n</code></pre> <p>Available compression options include:</p> <ul> <li><code>UNCOMPRESSED</code> - No compression, fastest read/write but largest file size</li> <li><code>SNAPPY</code> (default) - Fast compression/decompression, good balance of speed and size</li> <li><code>GZIP</code> - Good compression ratio, slower than Snappy but better compression</li> <li><code>BROTLI</code> - Good compression for text data, optimized for web content</li> <li><code>ZSTD</code> - Excellent compression ratio, modern algorithm with good speed</li> <li><code>LZ4</code> - Very fast compression/decompression, lower compression ratio</li> <li><code>LZ4_FRAME</code> - LZ4 with frame format, better compatibility</li> <li><code>LZO</code> - Fast compression, older algorithm</li> <li><code>BZ2</code> - High compression ratio, slower compression/decompression</li> <li><code>LZ4_HADOOP</code> - LZ4 optimized for Hadoop ecosystem</li> </ul> <pre><code>// Examples of different compression settings\nconst auto snappy_settings = rfl::parquet::Settings{}\n    .with_compression(rfl::parquet::Compression::SNAPPY);\n\nconst auto gzip_settings = rfl::parquet::Settings{}\n    .with_compression(rfl::parquet::Compression::GZIP);\n\nconst auto zstd_settings = rfl::parquet::Settings{}\n    .with_compression(rfl::parquet::Compression::ZSTD);\n\nconst auto uncompressed_settings = rfl::parquet::Settings{}\n    .with_compression(rfl::parquet::Compression::UNCOMPRESSED);\n</code></pre>"},{"location":"supported_formats/parquet/#loading-and-saving","title":"Loading and saving","text":"<p>You can also load and save to disk using a very similar syntax:</p> <pre><code>const rfl::Result&lt;std::vector&lt;Person&gt;&gt; result = rfl::parquet::load&lt;std::vector&lt;Person&gt;&gt;(\"/path/to/file.parquet\");\n\nconst auto people = std::vector&lt;Person&gt;{...};\nrfl::parquet::save(\"/path/to/file.parquet\", people);\n</code></pre> <p>With custom settings:</p> <pre><code>const auto settings = rfl::parquet::Settings{}\n    .with_compression(rfl::parquet::Compression::GZIP);\nrfl::parquet::save(\"/path/to/file.parquet\", people, settings);\n</code></pre>"},{"location":"supported_formats/parquet/#reading-from-and-writing-into-streams","title":"Reading from and writing into streams","text":"<p>You can also read from and write into any <code>std::istream</code> and <code>std::ostream</code> respectively.</p> <pre><code>const rfl::Result&lt;std::vector&lt;Person&gt;&gt; result = rfl::parquet::read&lt;std::vector&lt;Person&gt;&gt;(my_istream);\n\nconst auto people = std::vector&lt;Person&gt;{...};\nrfl::parquet::write(people, my_ostream);\n</code></pre> <p>With custom settings:</p> <pre><code>const auto settings = rfl::parquet::Settings{}\n    .with_compression(rfl::parquet::Compression::GZIP);\nrfl::parquet::write(people, my_ostream, settings);\n</code></pre>"},{"location":"supported_formats/parquet/#field-name-transformations","title":"Field name transformations","text":"<p>Like other formats, Parquet supports field name transformations. You can use processors like <code>SnakeCaseToCamelCase</code>:</p> <pre><code>const auto people = std::vector&lt;Person&gt;{...};\nconst auto result = rfl::parquet::read&lt;std::vector&lt;Person&gt;, rfl::SnakeCaseToCamelCase&gt;(bytes);\n</code></pre> <p>This will automatically convert field names from snake_case to camelCase during serialization and deserialization.</p>"},{"location":"supported_formats/parquet/#supported-processors","title":"Supported processors","text":"<p>The following processors are NOT supported and will cause compilation errors:</p> <ul> <li><code>rfl::AddTagsToVariants</code> - Cannot be used for tabular data</li> <li><code>rfl::NoOptionals</code> - Cannot be used for tabular data  </li> <li><code>rfl::DefaultIfMissing</code> - Cannot be used for tabular data</li> <li><code>rfl::NoExtraFields</code> - Cannot be used for tabular data</li> <li><code>rfl::NoFieldNames</code> - Cannot be used for tabular data</li> </ul> <pre><code>// \u2705 This works\nconst auto result = rfl::parquet::read&lt;std::vector&lt;Person&gt;, rfl::SnakeCaseToCamelCase&gt;(bytes);\n\n// \u274c This will cause compilation errors\nconst auto result = rfl::parquet::read&lt;std::vector&lt;Person&gt;, rfl::AddTagsToVariants&gt;(bytes);\nconst auto result = rfl::parquet::read&lt;std::vector&lt;Person&gt;, rfl::NoOptionals&gt;(bytes);\nconst auto result = rfl::parquet::read&lt;std::vector&lt;Person&gt;, rfl::DefaultIfMissing&gt;(bytes);\n</code></pre>"},{"location":"supported_formats/parquet/#enums-and-validation","title":"Enums and validation","text":"<p>Parquet supports enums and validated types. Enums are stored as strings:</p> <pre><code>enum class FirstName { Bart, Lisa, Maggie, Homer };\n\nstruct Person {\n    rfl::Rename&lt;\"firstName\", FirstName&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n    rfl::Validator&lt;unsigned int, rfl::Minimum&lt;0&gt;, rfl::Maximum&lt;130&gt;&gt; age;\n    rfl::Email email;\n};\n</code></pre>"},{"location":"supported_formats/parquet/#no-variant-types","title":"No variant types","text":"<p>Parquet does not support variant types like <code>std::variant</code>, <code>rfl::Variant</code>, or <code>rfl::TaggedUnion</code>. These types cannot be serialized to Parquet format.</p> <pre><code>// \u274c This will NOT work\nstruct Person {\n    std::string first_name;\n    std::variant&lt;std::string, int&gt; status;  // Variant - not supported\n    rfl::Variant&lt;std::string, int&gt; type;      // rfl::Variant - not supported\n    rfl::TaggedUnion&lt;\"type\", std::string, int&gt; category;  // TaggedUnion - not supported\n};\n</code></pre>"},{"location":"supported_formats/parquet/#limitations-of-tabular-formats","title":"Limitations of tabular formats","text":"<p>Parquet, like other tabular formats, has specific limitations that differ from hierarchical formats like JSON or XML:</p>"},{"location":"supported_formats/parquet/#no-nested-objects","title":"No nested objects","text":"<p>Unlike JSON or XML, Parquet cannot directly represent nested objects within a single row. Each field must be a primitive type, enum, or a simple container of primitives.</p> <pre><code>// This works fine\nstruct Person {\n    std::string first_name;\n    std::string last_name;\n    unsigned int age;\n};\n\n// This would NOT work as expected - nested objects are not automatically flattened\nstruct Address {\n    std::string street;\n    std::string city;\n};\n\nstruct Person {\n    std::string first_name;\n    std::string last_name;\n    Address address;  // \u274c This will cause compilation errors\n};\n</code></pre>"},{"location":"supported_formats/parquet/#using-rflflatten-for-nested-objects","title":"Using rfl::Flatten for nested objects","text":"<p>If you need to include nested objects, you can use <code>rfl::Flatten</code> to explicitly flatten them:</p> <pre><code>struct Address {\n    std::string street;\n    std::string city;\n};\n\nstruct Person {\n    std::string first_name;\n    std::string last_name;\n    rfl::Flatten&lt;Address&gt; address;  // \u2705 This will flatten the Address fields\n};\n\n// The resulting Parquet file will have columns: first_name, last_name, street, city\n</code></pre>"},{"location":"supported_formats/parquet/#collections-requirement","title":"Collections requirement","text":"<p>You must serialize collections, not individual objects: <pre><code>std::vector&lt;Person&gt; people = {...};  // \u2705 Correct\nPerson person = {...};               // \u274c Wrong - must be in a container\n</code></pre></p>"},{"location":"supported_formats/parquet/#no-arrays-except-bytestrings","title":"No arrays (except bytestrings)","text":"<p>Parquet does not support arrays of any type except for binary data (bytestrings). This includes arrays of primitive types, strings, and objects.</p> <pre><code>// \u274c This will NOT work\nstruct Person {\n    std::string first_name;\n    std::vector&lt;std::string&gt; hobbies;  // Array of strings - not supported\n    std::vector&lt;int&gt; scores;           // Array of integers - not supported\n    std::vector&lt;Address&gt; addresses;    // Array of objects - not supported\n};\n\n// \u2705 This works\nstruct Person {\n    std::string first_name;\n    std::string last_name;\n    std::vector&lt;char&gt; binary_data;      // Binary data - supported as bytestring\n};\n</code></pre>"},{"location":"supported_formats/parquet/#use-cases","title":"Use cases","text":"<p>Parquet is ideal for: - Data warehousing and analytics - Large datasets with repeated values - Integration with big data tools (Spark, Hadoop, etc.) - Simple, flat data structures with consistent types</p> <p>Parquet is less suitable for: - Complex nested data structures - Data with arrays or variant types - Frequent schema changes - Row-oriented access patterns - Small datasets where the overhead isn't justified - Data with complex object hierarchies</p>"},{"location":"supported_formats/supporting_your_own_format/","title":"Supporting your own format","text":"<p>In order to support your own serialization format, you need to implement a reader and a writer on top of whatever serialization libary you have chosen.</p> <p>The reader and writer constitute a thin layer between the serialization library of your choice and reflect-cpp.</p> <p>The requirements are laid down in the concepts IsReader and IsWriter and also documented below.</p> <p>Using the reader and the writer you can define your parser like this:</p> <pre><code>template &lt;class T&gt;\nusing YourParser = rfl::parsing::Parser&lt;YourReader, YourWriter, T&gt;;\n</code></pre> <p>This can then be used to implement a <code>read</code> function and a <code>write</code> function:</p> <pre><code>using InputVarType = typename YourReader::InputVarType;\nusing OutputVarType = typename YourWriter::OutputVarType;\n\ntemplate &lt;class T&gt;\nrfl::Result&lt;T&gt; read(const std::string&amp; _str) {\n    // This should be supported by whatever library you are\n    // using for your format.\n    const InputVarType root = str_to_input_var(_str);\n\n    // You can pass variables to the constructor, if necessary\n    const auto r = Reader(...); \n\n    return YourParser&lt;T&gt;::read(r, root);\n}\n\ntemplate &lt;class T&gt;\nstd::string write(const T&amp; _obj) {\n    // You can pass variables to the constructor, if necessary\n    auto w = Writer(...);\n\n    OutputVarType var = Parser&lt;T&gt;::write(w, _obj);\n\n    // This should be supported by whatever library you are\n    // using for your format.\n    return output_var_to_str(var);\n}\n</code></pre> <p>In the following two sections, we will provide templates for your <code>Reader</code> and <code>Writer</code>. You should probably just copy + paste this into your own code and fill in the blanks.</p> <p>As a reference, you can take a look at how this is done for JSON: https://github.com/getml/reflect-cpp/tree/main/include/rfl/json</p>"},{"location":"supported_formats/supporting_your_own_format/#implementing-your-own-writer","title":"Implementing your own writer","text":"<p>Because writers are somewhat simpler, we will start with them.</p> <p>Any Writer needs to define the following types:</p> <p>1) An <code>OutputArrayType</code>, which must be an array-like data structure. 2) An <code>OutputObjectType</code>, which must contain key-value pairs. 3) An <code>OutputVarType</code>, which must be able to represent either    <code>OutputArrayType</code>, <code>OutputObjectType</code> or a basic type (bool, integral,    floating point, std::string). We hesitate to call these \"primitive types\",    because primitive types in C++ are defined as a slightly different group    of types.</p> <p>It also needs to support the following methods:</p> <pre><code>struct Writer {\n    using OutputArrayType = ...;\n    using OutputObjectType = ...;\n    using OutputVarType = ...;\n\n  /// Sets an empty array as the root element of the document.\n  /// Some serialization formats require you to pass the expected size in\n  /// advance. If you are not working with such a format, you can ignore the\n  /// parameter `_size`. Returns the new array for further modification.\n  OutputArrayType array_as_root(const size_t _size) const noexcept;\n\n  /// Sets an empty object as the root element of the document.\n  /// Some serialization formats require you to pass the expected size in\n  /// advance. If you are not working with such a format, you can ignore the\n  /// parameter `_size`.\n  /// Returns the new object for further modification.\n  OutputObjectType object_as_root(const size_t _size) const noexcept;\n\n  /// Sets a null as the root element of the document. Returns OutputVarType\n  /// containing the null value.\n  OutputVarType null_as_root() const noexcept;\n\n  /// Sets a basic value (bool, numeric, string) as the root element of the\n  /// document. Returns an OutputVarType containing the new value.\n  template &lt;class T&gt;\n  OutputVarType value_as_root(const T&amp; _var) const noexcept;\n\n  /// Adds an empty array to an existing array. Returns the new\n  /// array for further modification.\n  OutputArrayType add_array_to_array(const size_t _size,\n                                     OutputArrayType* _parent) const noexcept;\n\n  /// Adds an empty array to an existing object. The key or name of the field is\n  /// signified by `_name`. Returns the new array for further modification.\n  OutputArrayType add_array_to_object(\n      const std::string_view&amp; _name, const size_t _size,\n      OutputObjectType* _parent) const noexcept;\n\n  /// Adds an empty object to an existing array. Returns the new\n  /// object for further modification.\n  OutputObjectType add_object_to_array(\n      const size_t _size, OutputArrayType* _parent) const noexcept;\n\n  /// Adds an empty object to an existing object. The key or name of the field\n  /// is signified by `_name`. Returns the new object for further modification.\n  OutputObjectType add_object_to_object(\n      const std::string_view&amp; _name, const size_t _size,\n      OutputObjectType* _parent) const noexcept;\n\n  /// Adds a basic value (bool, numeric, string) to an array. Returns an\n  /// OutputVarType containing the new value.\n  template &lt;class T&gt;\n  OutputVarType add_value_to_array(const T&amp; _var,\n                                   OutputArrayType* _parent) const noexcept;\n\n  /// Adds a basic value (bool, numeric, string) to an existing object. The key\n  /// or name of the field is signified by `name`. Returns an\n  /// OutputVarType containing the new value.\n  template &lt;class T&gt;\n  OutputVarType add_value_to_object(const std::string_view&amp; _name, const T&amp; _var,\n                                    OutputObjectType* _parent) const noexcept;\n\n  /// Adds a null value to an array. Returns an\n  /// OutputVarType containing the null value.\n  OutputVarType add_null_to_array(OutputArrayType* _parent) const noexcept;\n\n  /// Adds a null value to an existing object. The key\n  /// or name of the field is signified by `name`. Returns an\n  /// OutputVarType containing the null value.\n  OutputVarType add_null_to_object(const std::string_view&amp; _name,\n                                   OutputObjectType* _parent) const noexcept;\n\n  /// Signifies to the writer that we do not want to add any further elements to\n  /// this array. Some serialization formats require this. If you are working\n  /// with a serialization format that doesn't, just leave the function empty.\n  void end_array(OutputArrayType* _arr) const noexcept;\n\n  /// Signifies to the writer that we do not want to add any further elements to\n  /// this object. Some serialization formats require this. If you are working\n  /// with a serialization format that doesn't, just leave the function empty.\n  void end_object(OutputObjectType* _obj) const noexcept;\n};\n</code></pre>"},{"location":"supported_formats/supporting_your_own_format/#implementing-your-own-reader","title":"Implementing your own reader","text":"<p>Any Reader needs to define the following:</p> <p>1) An <code>InputArrayType</code>, which must be an array-like data structure. 2) An <code>InputObjectType</code>, which must contain key-value pairs. 3) An <code>InputVarType</code>, which must be able to represent either    <code>InputArrayType</code>, <code>InputObjectType</code> or a basic type (bool, integral,    floating point, std::string). 4) A <code>static constexpr bool has_custom_constructor&lt;T&gt;</code>, that determines    whether the class in question as a custom constructor, which might    be called something like <code>from_json_obj(...)</code>. If you do not want to    support this functionality, just set it to false.</p> <p>It also needs to support the following methods:</p> <pre><code>struct Reader {\n    using InputArrayType = ...;\n    using InputObjectType = ...;\n    using InputVarType = ...;\n\n    /// If you do not want to support custom constructors,\n    /// just set this to false.\n    template &lt;class T&gt;\n    static constexpr bool has_custom_constructor = false;\n\n    /// Retrieves a particular field from an array.\n    /// Returns an rfl::Error if the index is out of bounds.\n    /// If your format is schemaful, you do not need this.\n    rfl::Result&lt;InputVarType&gt; get_field_from_array(\n        const size_t _idx, const InputArrayType _arr) const noexcept {...}\n\n    /// Retrieves a particular field from an object.\n    /// Returns an rfl::Error if the field cannot be found.\n    /// If your format is schemaful, you do not need this.\n    rfl::Result&lt;InputVarType&gt; get_field_from_object(\n        const std::string&amp; _name, const InputObjectType&amp; _obj) const noexcept {...}\n\n    /// Determines whether a variable is empty (the NULL type).\n    bool is_empty(const InputVarType&amp; _var) const noexcept {...}\n\n    /// Cast _var as a basic type (bool, integral,\n    /// floating point, std::string).\n    /// Returns an rfl::Error if it cannot be cast\n    /// as that type\n    template &lt;class T&gt;\n    rfl::Result&lt;T&gt; to_basic_type(const InputVarType&amp; _var) const noexcept {...}\n\n    /// Casts _var as an InputArrayType.\n    /// Returns an rfl::Error if `_var` cannot be cast as an array.\n    rfl::Result&lt;InputArrayType&gt; to_array(const InputVarType&amp; _var) const noexcept {...}\n\n    /// Casts _var as an InputObjectType.\n    /// Returns an rfl::Error if `_var` cannot be cast as an object.\n    rfl::Result&lt;InputObjectType&gt; to_object(\n        const InputVarType&amp; _var) const noexcept {...}\n\n    /// Iterates through an array and inserts the values into the array\n    /// reader. See below for a more detailed explanation.\n    template &lt;class ArrayReader&gt;\n    std::optional&lt;Error&gt; read_array(const ArrayReader&amp; _array_reader,\n                                    const InputArrayType&amp; _arr) const noexcept {...}\n\n    /// Iterates through an object and inserts the key-value pairs into the object \n    /// reader. See below for a more detailed explanation.\n    template &lt;class ObjectReader&gt;\n    std::optional&lt;Error&gt; read_object(const ObjectReader&amp; _object_reader,\n                                     const InputObjectType&amp; _obj) const noexcept {...}\n\n    /// Constructs T using its custom constructor. This will only be triggered if\n    /// T was determined to have a custom constructor by\n    /// static constexpr bool has_custom_constructor, as defined above.\n    /// Returns an rfl::Error, if the custom constructor throws an exception.\n    template &lt;class T&gt;\n    rfl::Result&lt;T&gt; use_custom_constructor(\n        const InputVarType&amp; _var) const noexcept {\n        // If you do not want to support this functionality,\n        // just return this.\n        return rfl::error(\"Not supported.\");\n    }\n};\n</code></pre> <p>Of these methods, <code>read_array</code> and <code>read_object</code> probably require further explanation.</p>"},{"location":"supported_formats/supporting_your_own_format/#read_array","title":"<code>read_array</code>","text":"<p><code>read_array</code> expects an <code>ArrayReader</code> class which might come in several forms. But all of these forms have a method with the following signature:</p> <pre><code>std::optional&lt;Error&gt; read(const InputVarType&amp; _var) const noexcept;\n</code></pre> <p>Within your implementation of <code>read_array</code>, you must iterate through the array passed to the function and then insert the resulting values into <code>array_reader.read</code>. If  <code>array_reader.read</code> returns an error, then you must return that error immediately.</p>"},{"location":"supported_formats/supporting_your_own_format/#read_object","title":"<code>read_object</code>","text":"<p><code>read_object</code> expects an <code>ObjectReader</code> class which might come in several forms. But all of these forms have a method with the following signature:</p> <pre><code>void read(const std::string_view&amp; _name,\n          const InputVarType&amp; _var) const noexcept;\n</code></pre> <p>Within your implementation of <code>read_object</code>, you must iterate through the object passed to the function and then insert the resulting key-value-pairs into <code>object_reader.read</code>.</p>"},{"location":"supported_formats/supporting_your_own_format/#additional-requirements-for-schemaful-formats","title":"Additional requirements for schemaful formats","text":"<p>Schemaful formats, like Apache Avro or Cap'n Proto,  are somewhat more complicated than schemaless ones. There are additional factors to consider which do not apply schemaless formats:</p> <ol> <li> <p>Schemaful formats needs to differentiate between objects, for which     the field names are known at compile time and maps, for which the    field names are not known at compile time. In schemaless formats, there    is no differentiation.</p> </li> <li> <p>Schemaful formats needs an explicit union types. This also means that    many of the problems we have with serializing <code>std::variant</code> which    requires us to develop concepts like <code>rfl::TaggedUnion</code> simply do not    apply to schemaful formats - the problem is already solved.</p> </li> </ol>"},{"location":"supported_formats/supporting_your_own_format/#additional-requirements-for-schemaful-writers","title":"Additional requirements for schemaful writers","text":"<p>Any schemaful reader additionally needs to define the following:</p> <p>1) An <code>OutputMapType</code>, which must contain key-value pairs. 2) An <code>OutputUnionType</code>, which represents an explicit union.</p> <pre><code>struct Writer {\n  using OutputArrayType = ...;\n  using OutputMapType = ...;\n  using OutputObjectType = ...;\n  using OutputUnionType = ...;\n  using OutputVarType = ...;\n\n  /// Sets an empty map as the root element of the document.\n  /// Some serialization formats require you to pass the expected size in\n  /// advance. If you are not working with such a format, you can ignore the\n  /// parameter `size`. Returns the new array for further modification.\n  OutputMapType map_as_root(const size_t _size) const noexcept;\n\n  /// Sets an empty union as the root element of the document.\n  OutputUnionType union_as_root() const noexcept;\n\n  /// Adds an empty array to an existing map. Returns the new\n  /// array for further modification.\n  OutputArrayType add_array_to_map(const std::string_view&amp; _name,\n                                   const size_t _size,\n                                   OutputMapType* _parent) const noexcept;\n\n  /// Adds an empty array to an existing union.\n  /// The index refers to the index of the element in the union.\n  /// Returns the new array for further modification.\n  OutputArrayType add_array_to_union(const size_t _index, const size_t _size,\n                                     OutputUnionType* _parent) const noexcept;\n\n  /// Adds an empty map to an existing array. Returns the new\n  /// map for further modification.\n  OutputMapType add_map_to_array(const size_t _size,\n                                 OutputArrayType* _parent) const noexcept;\n\n  /// Adds an empty map to an existing map. The key or name of the field\n  /// is signified by `name`. Returns the new map for further modification.\n  OutputMapType add_map_to_map(const std::string_view&amp; _name,\n                               const size_t _size,\n                               OutputMapType* _parent) const noexcept;\n\n  /// Adds an empty map to an existing object. The key or name of the field\n  /// is signified by `name`. Returns the new map for further modification.\n  OutputMapType add_map_to_object(const std::string_view&amp; _name,\n                                  const size_t _size,\n                                  OutputObjectType* _parent) const noexcept;\n\n  /// Adds an empty map to an existing union.\n  /// The index refers to the index of the element in the union.\n  /// Returns the new map for further modification.\n  OutputMapType add_map_to_union(const size_t _index, const size_t _size,\n                                 OutputUnionType* _parent) const noexcept;\n\n  /// Adds an empty object to an existing map. The key or name of the field\n  /// is signified by `name`. Returns the new object for further modification.\n  OutputObjectType add_object_to_map(const std::string_view&amp; _name,\n                                     const size_t _size,\n                                     OutputMapType* _parent) const noexcept;\n\n  /// Adds an empty object to an existing union.\n  /// The index refers to the index of the element in the union.\n  /// Returns the new object for further modification.\n  OutputObjectType add_object_to_union(const size_t _index, const size_t _size,\n                                       OutputUnionType* _parent) const noexcept;\n\n  /// Adds an empty union to an existing array. Returns the new\n  /// union for further modification.\n  OutputUnionType add_union_to_array(OutputArrayType* _parent) const noexcept;\n\n  /// Adds an empty union to an existing map. The key or name of the field\n  /// is signified by `name`. Returns the new union for further modification.\n  OutputUnionType add_union_to_map(const std::string_view&amp; _name,\n                                   OutputMapType* _parent) const noexcept;\n\n  /// Adds an empty union to an existing object. The key or name of the field\n  /// is signified by `name`. Returns the new union for further modification.\n  OutputUnionType add_union_to_object(const std::string_view&amp; _name,\n                                      OutputObjectType* _parent) const noexcept;\n\n  /// Adds an empty union to an existing union.\n  /// The index refers to the index of the element in the union.\n  /// Returns the new union for further modification.\n  OutputUnionType add_union_to_union(const size_t _index,\n                                     OutputUnionType* _parent) const noexcept;\n\n  /// Adds a null value to a map. Returns an\n  /// OutputVarType containing the null value.\n  OutputVarType add_null_to_map(const std::string_view&amp; _name,\n                                OutputMapType* _parent) const noexcept;\n\n  /// Adds a null value to a union. Returns an\n  /// OutputVarType containing the null value.\n  OutputVarType add_null_to_union(const size_t _index,\n                                  OutputUnionType* _parent) const noexcept;\n\n  /// Adds a basic value (bool, numeric, string) to an existing map. The key\n  /// or name of the field is signified by `name`. Returns an\n  /// OutputVarType containing the new value.\n  template &lt;class T&gt;\n  OutputVarType add_value_to_map(const std::string_view&amp; _name, const T&amp; _var,\n                                 OutputMapType* _parent) const noexcept; \n\n  /// Adds a basic value (bool, numeric, string) to an existing union. The key\n  /// or name of the field is signified by `name`. Returns an\n  /// OutputVarType containing the new value.\n  template &lt;class T&gt;\n  OutputVarType add_value_to_union(const size_t _index, const T&amp; _var,\n                                   OutputUnionType* _parent) const noexcept;\n\n  /// Signifies to the writer that we do not want to add any further elements to\n  /// this map. Some serialization formats require this. If you are working\n  /// with a serialization format that doesn't, just leave the function empty.\n  void end_map(OutputMapType* _obj) const noexcept; \n\n};\n</code></pre>"},{"location":"supported_formats/supporting_your_own_format/#additional-requirements-for-schemaful-readers","title":"Additional requirements for schemaful readers","text":"<p>Any schemaful reader additionally needs to define the following:</p> <p>1) An <code>InputMapType</code>, which must contain key-value pairs. 2) An <code>InputUnionType</code>, which represents an explicit union.</p> <pre><code>struct Reader {\n  using InputArrayType = ...;\n  using InputObjectType = ...;\n  using InputMapType = ...;\n  using InputUnionType = ...;\n  using InputVarType = ...;\n\n  /// A schemaful reader needs to differentiate between objects, for which\n  /// the field names are known at compile time and maps, for which the\n  /// field names are not known at compile time.\n  rfl::Result&lt;InputMapType&gt; to_map(const InputVarType&amp; _var) const noexcept;\n\n  /// read_map works exactly the same as read_object in schemaless formats.\n  template &lt;class MapReader&gt;\n  std::optional&lt;Error&gt; read_map(const MapReader&amp; _map_reader,\n                                const InputMapType&amp; _map) const noexcept;\n\n  /// A schemaful reader needs an explicit union type.\n  rfl::Result&lt;InputUnionType&gt; to_union(const InputVarType&amp; _var) const noexcept;\n\n  /// read_union needs to be able to take an InputUnionType and return the corresponding\n  /// variant (like std::variant or rfl::Variant). \n  template &lt;class VariantType, class UnionReaderType&gt;\n  rfl::Result&lt;VariantType&gt; read_union(\n      const InputUnionType&amp; _union) const noexcept;\n};\n</code></pre>"},{"location":"supported_formats/toml/","title":"TOML","text":"<p>For TOML support, you must also include the header <code>&lt;rfl/toml.hpp&gt;</code> and include the toml++ library. Furthermore, when compiling reflect-cpp, you need to pass <code>-DREFLECTCPP_TOML=ON</code> to cmake. If you are using vcpkg or Conan, there should be an appropriate feature (vcpkg) or option (Conan) that will abstract this away for you.</p>"},{"location":"supported_formats/toml/#reading-and-writing","title":"Reading and writing","text":"<p>Suppose you have a struct like this:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n    std::vector&lt;Person&gt; children;\n};\n</code></pre> <p>You can parse TOML strings like this:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::toml::read&lt;Person&gt;(toml_string);\n</code></pre> <p>A <code>person</code> can be serialized like this:</p> <pre><code>const auto person = Person{...};\nconst std::string toml_string = rfl::toml::write(person);\n</code></pre>"},{"location":"supported_formats/toml/#loading-and-saving","title":"Loading and saving","text":"<p>You can also load and save to disc using a very similar syntax:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::toml::load&lt;Person&gt;(\"/path/to/file.toml\");\n\nconst auto person = Person{...};\nrfl::toml::save(\"/path/to/file.toml\", person);\n</code></pre>"},{"location":"supported_formats/toml/#reading-from-and-writing-into-streams","title":"Reading from and writing into streams","text":"<p>You can also read from and write into any <code>std::istream</code> and <code>std::ostream</code> respectively.</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::toml::read&lt;Person&gt;(my_istream);\n\nconst auto person = Person{...};\nrfl::toml::write(person, my_ostream);\n</code></pre> <p>Note that <code>std::cout</code> is also an ostream, so this works as well:</p> <pre><code>rfl::toml::write(person, std::cout) &lt;&lt; std::endl;\n</code></pre>"},{"location":"supported_formats/toml/#custom-constructors","title":"Custom constructors","text":"<p>One of the great things about C++ is that it gives you control over when and how you code is compiled.</p> <p>For large and complex systems of structs, it is often a good idea to split up your code into smaller compilation units. You can do so using custom constructors.</p> <p>For the TOML format, these must be a static function on your struct or class called <code>from_toml_obj</code> that take a <code>rfl::toml::Reader::InputVarType</code> as input and return the class or the class wrapped in <code>rfl::Result</code>.</p> <p>In your header file you can write something like this:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n\n    using TOMLVar = typename rfl::toml::Reader::InputVarType;\n    static rfl::Result&lt;Person&gt; from_toml_obj(const TOMLVar&amp; _obj);\n};\n</code></pre> <p>And in your source file, you implement <code>from_toml_obj</code> as follows:</p> <pre><code>rfl::Result&lt;Person&gt; Person::from_toml_obj(const TOMLVar&amp; _obj) {\n    const auto from_nt = [](auto&amp;&amp; _nt) {\n        return rfl::from_named_tuple&lt;Person&gt;(std::move(_nt));\n    };\n    return rfl::toml::read&lt;rfl::named_tuple_t&lt;Person&gt;&gt;(_obj)\n        .transform(from_nt);\n}\n</code></pre> <p>This will force the compiler to only compile the TOML parsing when the source file is compiled.</p>"},{"location":"supported_formats/ubjson/","title":"UBJSON","text":"<p>For UBJSON support, you must also include the header <code>&lt;rfl/ubjson.hpp&gt;</code> and include the jsoncons library.  Note that it is header-only. Furthermore, when compiling reflect-cpp, you need to pass <code>-DREFLECTCPP_UBJSON=ON</code> to cmake. If you are using vcpkg or Conan, there should be an appropriate feature (vcpkg) or option (Conan) that will abstract this away for you.</p> <p>UBJSON is a JSON-like binary format.</p>"},{"location":"supported_formats/ubjson/#reading-and-writing","title":"Reading and writing","text":"<p>Suppose you have a struct like this:</p> <pre><code>struct Person {\n    std::string first_name;\n    std::string last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n    std::vector&lt;Person&gt; children;\n};\n</code></pre> <p>A <code>Person</code> can be serialized to a bytes vector like this:</p> <pre><code>const auto person = Person{...};\nconst std::vector&lt;char&gt; bytes = rfl::ubjson::write(person);\n</code></pre> <p>You can parse bytes like this:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::ubjson::read&lt;Person&gt;(bytes);\n</code></pre>"},{"location":"supported_formats/ubjson/#loading-and-saving","title":"Loading and saving","text":"<p>You can also load and save to disc using a very similar syntax:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::ubjson::load&lt;Person&gt;(\"/path/to/file.ubjson\");\n\nconst auto person = Person{...};\nrfl::ubjson::save(\"/path/to/file.ubjson\", person);\n</code></pre>"},{"location":"supported_formats/ubjson/#reading-from-and-writing-into-streams","title":"Reading from and writing into streams","text":"<p>You can also read from and write into any <code>std::istream</code> and <code>std::ostream</code> respectively.</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::ubjson::read&lt;Person&gt;(my_istream);\n\nconst auto person = Person{...};\nrfl::ubjson::write(person, my_ostream);\n</code></pre> <p>Note that <code>std::cout</code> is also an ostream, so this works as well:</p> <pre><code>rfl::ubjson::write(person, std::cout) &lt;&lt; std::endl;\n</code></pre> <p>(Since UBJSON is a binary format, the readability of this will be limited, but it might be useful for debugging).</p>"},{"location":"supported_formats/ubjson/#custom-constructors","title":"Custom constructors","text":"<p>One of the great things about C++ is that it gives you control over when and how you code is compiled.</p> <p>For large and complex systems of structs, it is often a good idea to split up your code into smaller compilation units. You can do so using custom constructors.</p> <p>For the UBJSON format, these must be a static function on your struct or class called <code>from_ubjson</code> that take a <code>rfl::ubjson::Reader::InputVarType</code> as input and return the class or the class wrapped in <code>rfl::Result</code>.</p> <p>In your header file you can write something like this:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n\n    using InputVarType = typename rfl::ubjson::Reader::InputVarType;\n    static rfl::Result&lt;Person&gt; from_ubjson(const InputVarType&amp; _obj);\n};\n</code></pre> <p>And in your source file, you implement <code>from_ubjson</code> as follows:</p> <pre><code>rfl::Result&lt;Person&gt; Person::from_ubjson(const InputVarType&amp; _obj) {\n    const auto from_nt = [](auto&amp;&amp; _nt) {\n        return rfl::from_named_tuple&lt;Person&gt;(std::move(_nt));\n    };\n    return rfl::ubjson::read&lt;rfl::named_tuple_t&lt;Person&gt;&gt;(_obj)\n        .transform(from_nt);\n}\n</code></pre> <p>This will force the compiler to only compile the UBJSON parsing when the source file is compiled.</p>"},{"location":"supported_formats/xml/","title":"XML","text":"<p>For XML support, you must also include the header <code>&lt;rfl/xml.hpp&gt;</code> and include the pugixml library. Furthermore, when compiling reflect-cpp, you need to pass <code>-DREFLECTCPP_XML=ON</code> to cmake. If you are using vcpkg or Conan, there should be an appropriate feature (vcpkg) or option (Conan) that will abstract this away for you.</p>"},{"location":"supported_formats/xml/#simple-example","title":"Simple example","text":"<p>Consider the following example:</p> <pre><code>using Age = rfl::Validator&lt;unsigned int, rfl::Minimum&lt;0&gt;, rfl::Maximum&lt;130&gt;&gt;;\n\nstruct Person {\n  rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n  rfl::Rename&lt;\"lastName\", std::string&gt; last_name = \"Simpson\";\n  std::string town = \"Springfield\";\n  rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n  Age age;\n  rfl::Email email;\n  std::vector&lt;Person&gt; child;\n};\n\nconst auto bart = Person{.first_name = \"Bart\",\n                       .birthday = \"1987-04-19\",\n                       .age = 10,\n                       .email = \"bart@simpson.com\"};\n\nconst auto lisa = Person{.first_name = \"Lisa\",\n                       .birthday = \"1987-04-19\",\n                       .age = 8,\n                       .email = \"lisa@simpson.com\"};\n\nconst auto maggie = Person{.first_name = \"Maggie\",\n                         .birthday = \"1987-04-19\",\n                         .age = 0,\n                         .email = \"maggie@simpson.com\"};\n\nconst auto homer = Person{.first_name = \"Homer\",\n                        .birthday = \"1987-04-19\",\n                        .age = 45,\n                        .email = \"homer@simpson.com\",\n                        .child = std::vector&lt;Person&gt;({bart, lisa, maggie})};\n\nrfl::xml::write(homer);\n</code></pre> <p>This will result in the following XML string:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;Person&gt;\n    &lt;firstName&gt;Homer&lt;/firstName&gt;\n    &lt;lastName&gt;Simpson&lt;/lastName&gt;\n    &lt;town&gt;Springfield&lt;/town&gt;\n    &lt;birthday&gt;1987-04-19&lt;/birthday&gt;\n    &lt;age&gt;45&lt;/age&gt;\n    &lt;email&gt;homer@simpson.com&lt;/email&gt;\n    &lt;child&gt;\n        &lt;firstName&gt;Bart&lt;/firstName&gt;\n        &lt;lastName&gt;Simpson&lt;/lastName&gt;\n        &lt;town&gt;Springfield&lt;/town&gt;\n        &lt;birthday&gt;1987-04-19&lt;/birthday&gt;\n        &lt;age&gt;10&lt;/age&gt;\n        &lt;email&gt;bart@simpson.com&lt;/email&gt;\n    &lt;/child&gt;\n    &lt;child&gt;\n        &lt;firstName&gt;Lisa&lt;/firstName&gt;\n        &lt;lastName&gt;Simpson&lt;/lastName&gt;\n        &lt;town&gt;Springfield&lt;/town&gt;\n        &lt;birthday&gt;1987-04-19&lt;/birthday&gt;\n        &lt;age&gt;8&lt;/age&gt;\n        &lt;email&gt;lisa@simpson.com&lt;/email&gt;\n    &lt;/child&gt;\n    &lt;child&gt;\n        &lt;firstName&gt;Maggie&lt;/firstName&gt;\n        &lt;lastName&gt;Simpson&lt;/lastName&gt;\n        &lt;town&gt;Springfield&lt;/town&gt;\n        &lt;birthday&gt;1987-04-19&lt;/birthday&gt;\n        &lt;age&gt;0&lt;/age&gt;\n        &lt;email&gt;maggie@simpson.com&lt;/email&gt;\n    &lt;/child&gt;\n&lt;/Person&gt;\n</code></pre> <p>Unlike most other formats, XML distinguishes between attributes and nodes.  If you want something to be displayed as an attribute, you must mark it as such:</p> <pre><code>using Age = rfl::Validator&lt;unsigned int, rfl::Minimum&lt;0&gt;, rfl::Maximum&lt;130&gt;&gt;;\n\nstruct Person {\n  rfl::Rename&lt;\"firstName\", rfl::Attribute&lt;std::string&gt;&gt; first_name;\n  rfl::Rename&lt;\"lastName\", rfl::Attribute&lt;std::string&gt;&gt; last_name = \"Simpson\";\n  rfl::Attribute&lt;std::string&gt; town = \"Springfield\";\n  rfl::Attribute&lt;rfl::Timestamp&lt;\"%Y-%m-%d\"&gt;&gt; birthday;\n  rfl::Attribute&lt;Age&gt; age;\n  rfl::Attribute&lt;rfl::Email&gt; email;\n  std::vector&lt;Person&gt; child;\n};\n\nconst auto bart = Person{.first_name = \"Bart\",\n                         .birthday = \"1987-04-19\",\n                         .age = 10,\n                         .email = \"bart@simpson.com\"};\n\nconst auto lisa = Person{.first_name = \"Lisa\",\n                         .birthday = \"1987-04-19\",\n                         .age = 8,\n                         .email = \"lisa@simpson.com\"};\n\nconst auto maggie = Person{.first_name = \"Maggie\",\n                           .birthday = \"1987-04-19\",\n                           .age = 0,\n                           .email = \"maggie@simpson.com\"};\n\nconst auto homer = Person{.first_name = \"Homer\",\n                          .birthday = \"1987-04-19\",\n                          .age = 45,\n                          .email = \"homer@simpson.com\",\n                          .child = std::vector&lt;Person&gt;({bart, lisa, maggie})};\n\nrfl::xml::write(homer);\n</code></pre> <p>This will result in the following XML string:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;Person firstName=\"Homer\" lastName=\"Simpson\" town=\"Springfield\" birthday=\"1987-04-19\" age=\"45\" email=\"homer@simpson.com\"&gt;\n    &lt;child firstName=\"Bart\" lastName=\"Simpson\" town=\"Springfield\" birthday=\"1987-04-19\" age=\"10\" email=\"bart@simpson.com\" /&gt;\n    &lt;child firstName=\"Lisa\" lastName=\"Simpson\" town=\"Springfield\" birthday=\"1987-04-19\" age=\"8\" email=\"lisa@simpson.com\" /&gt;\n    &lt;child firstName=\"Maggie\" lastName=\"Simpson\" town=\"Springfield\" birthday=\"1987-04-19\" age=\"0\" email=\"maggie@simpson.com\" /&gt;\n&lt;/Person&gt;\n</code></pre> <p>Note that only boolean values, string values, integral values or floating point values can be represented as attributes.</p> <p>There also is a special field name called <code>xml_content</code> to be used when you want a value directly inserted into the content. Again, only boolean values, string values, integral values or floating point values can be represented this way:</p> <pre><code>struct Person {\n  std::string xml_content;\n  rfl::Attribute&lt;std::string&gt; town = \"Springfield\";\n  rfl::Attribute&lt;rfl::Timestamp&lt;\"%Y-%m-%d\"&gt;&gt; birthday;\n  rfl::Attribute&lt;rfl::Email&gt; email;\n  std::vector&lt;Person&gt; child;\n};\n\nconst auto bart = Person{.xml_content = \"Bart Simpson\",\n                         .birthday = \"1987-04-19\",\n                         .email = \"bart@simpson.com\"};\n\nconst auto lisa = Person{.xml_content = \"Lisa Simpson\",\n                         .birthday = \"1987-04-19\",\n                         .email = \"lisa@simpson.com\"};\n\nconst auto maggie = Person{.xml_content = \"Maggie Simpson\",\n                           .birthday = \"1987-04-19\",\n                           .email = \"maggie@simpson.com\"};\n\nconst auto homer = Person{.xml_content = \"Homer Simpson\",\n                          .birthday = \"1987-04-19\",\n                          .email = \"homer@simpson.com\",\n                          .child = std::vector&lt;Person&gt;({bart, lisa, maggie})};\n\nrfl::xml::write(homer);\n</code></pre> <p>This will result in the following XML string:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;Person town=\"Springfield\" birthday=\"1987-04-19\" email=\"homer@simpson.com\"&gt;Homer Simpson&lt;child town=\"Springfield\" birthday=\"1987-04-19\" email=\"bart@simpson.com\"&gt;Bart Simpson&lt;/child&gt;\n    &lt;child town=\"Springfield\" birthday=\"1987-04-19\" email=\"lisa@simpson.com\"&gt;Lisa Simpson&lt;/child&gt;\n    &lt;child town=\"Springfield\" birthday=\"1987-04-19\" email=\"maggie@simpson.com\"&gt;Maggie Simpson&lt;/child&gt;\n&lt;/Person&gt;\n</code></pre>"},{"location":"supported_formats/xml/#limitations-of-the-xml-format","title":"Limitations of the XML format","text":""},{"location":"supported_formats/xml/#there-must-be-exactly-one-root-node","title":"There must be exactly one root node","text":"<p>The XML format requires that there must be exactly one root node.  Other formats, like JSON, allow you to have an array as the root element. XML disallows that.</p>"},{"location":"supported_formats/xml/#the-root-node-must-have-a-name","title":"The root node must have a name","text":"<p>As you may have noticed, reflect-cpp uses the names of fields as the names of the XML nodes or attributes. However, the root node does not have a field name associated with it. So reflect-cpp will use the name of the struct as the name of the root node. This is a problem when the root node is a template parameter, because the name of the root node cannot contain \"&lt;\" or \"&gt;\".</p> <p>In this case, you can explicitly set a root node name like this:</p> <pre><code>rfl::xml::write&lt;\"NameOfTheRootNode\"&gt;(homer);\n</code></pre>"},{"location":"supported_formats/xml/#no-nested-arrays","title":"No nested arrays","text":"<p>Unlike JSON, XML doesn't have an explicit concept of arrays. Array-like structures are represented by simply writing the same field over and over again (i.e. Homer's children in the examples above).</p> <p>This also implies that something like this cannot be properly represented in XML:</p> <pre><code>struct Person {\n  std::string name;\n  std::vector&lt;std::vector&lt;Person&gt;&gt; child;\n};\n</code></pre> <p>There is no way to represent a vector of vectors in XML. It's a limitation of the format.</p>"},{"location":"supported_formats/xml/#integers-cannot-be-tags","title":"Integers cannot be tags","text":"<p>In JSON, it is possible to represent a map with integers as keys like this:</p> <pre><code>std::map&lt;int, std::string&gt; homer;\nhomer[1] = \"Homer\";\nhomer[2] = \"Simpson\";\n\nrfl::json::write(homer);\n</code></pre> <p>This will be represented as follows:</p> <pre><code>{\"1\":\"Homer\",\"2\":\"Simpson\"}\n</code></pre> <p>In XML, this is impossible. The XML standard requires that the tag must not start with an integer.</p>"},{"location":"supported_formats/xml/#loading-and-saving","title":"Loading and saving","text":"<p>You can also load and save to disc using a very similar syntax:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::xml::load&lt;Person&gt;(\"/path/to/file.xml\");\n\nconst auto person = Person{...};\nrfl::xml::save(\"/path/to/file.xml\", person);\n</code></pre>"},{"location":"supported_formats/yaml/","title":"YAML","text":"<p>For YAML support, you must also include the header <code>&lt;rfl/yaml.hpp&gt;</code> and include the yaml-cpp library. Furthermore, when compiling reflect-cpp, you need to pass <code>-DREFLECTCPP_YAML=ON</code> to cmake. If you are using vcpkg or Conan, there should be an appropriate feature (vcpkg) or option (Conan) that will abstract this away for you.</p>"},{"location":"supported_formats/yaml/#reading-and-writing","title":"Reading and writing","text":"<p>Suppose you have a struct like this:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n    std::vector&lt;Person&gt; children;\n};\n</code></pre> <p>You can parse YAML strings like this:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::yaml::read&lt;Person&gt;(yaml_string);\n</code></pre> <p>A <code>Person</code> can be serialized like this:</p> <pre><code>const auto person = Person{...};\nconst std::string yaml_string = rfl::yaml::write(person);\n</code></pre>"},{"location":"supported_formats/yaml/#loading-and-saving","title":"Loading and saving","text":"<p>You can also load and save to disc using a very similar syntax:</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::yaml::load&lt;Person&gt;(\"/path/to/file.yml\");\n\nconst auto person = Person{...};\nrfl::yaml::save(\"/path/to/file.yml\", person);\n</code></pre>"},{"location":"supported_formats/yaml/#reading-from-and-writing-into-streams","title":"Reading from and writing into streams","text":"<p>You can also read from and write into any <code>std::istream</code> and <code>std::ostream</code> respectively.</p> <pre><code>const rfl::Result&lt;Person&gt; result = rfl::yaml::read&lt;Person&gt;(my_istream);\n\nconst auto person = Person{...};\nrfl::yaml::write(person, my_ostream);\n</code></pre> <p>Note that <code>std::cout</code> is also an ostream, so this works as well:</p> <pre><code>rfl::yaml::write(person, std::cout) &lt;&lt; std::endl;\n</code></pre>"},{"location":"supported_formats/yaml/#custom-constructors","title":"Custom constructors","text":"<p>One of the great things about C++ is that it gives you control over when and how you code is compiled.</p> <p>For large and complex systems of structs, it is often a good idea to split up your code into smaller compilation units. You can do so using custom constructors.</p> <p>For the YAML format, these must be a static function on your struct or class called <code>from_yaml_obj</code> that take a <code>rfl::yaml::Reader::InputVarType</code> as input and return the class or the class wrapped in <code>rfl::Result</code>.</p> <p>In your header file you can write something like this:</p> <pre><code>struct Person {\n    rfl::Rename&lt;\"firstName\", std::string&gt; first_name;\n    rfl::Rename&lt;\"lastName\", std::string&gt; last_name;\n    rfl::Timestamp&lt;\"%Y-%m-%d\"&gt; birthday;\n\n    using YAMLVar = typename rfl::yaml::Reader::InputVarType;\n    static rfl::Result&lt;Person&gt; from_yaml_obj(const YAMLVar&amp; _obj);\n};\n</code></pre> <p>And in your source file, you implement <code>from_yaml_obj</code> as follows:</p> <pre><code>rfl::Result&lt;Person&gt; Person::from_yaml_obj(const YAMLVar&amp; _obj) {\n    const auto from_nt = [](auto&amp;&amp; _nt) {\n        return rfl::from_named_tuple&lt;Person&gt;(std::move(_nt));\n    };\n    return rfl::yaml::read&lt;rfl::named_tuple_t&lt;Person&gt;&gt;(_obj)\n        .transform(from_nt);\n}\n</code></pre> <p>This will force the compiler to only compile the YAML parsing when the source file is compiled.</p>"}]}